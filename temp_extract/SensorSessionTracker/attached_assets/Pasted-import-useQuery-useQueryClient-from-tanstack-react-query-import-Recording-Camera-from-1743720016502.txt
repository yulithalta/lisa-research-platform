import { useQuery, useQueryClient } from "@tanstack/react-query";
import { Recording, Camera } from "@shared/schema";
import { Card, CardContent, CardHeader, CardTitle, CardDescription, CardFooter } from "@/components/ui/card";
import { Loader2, Play, Download, Search, Check, X, ChevronUp, ChevronDown, Trash2 } from "lucide-react";
import { format, formatDuration, intervalToDuration } from "date-fns";
import { es } from "date-fns/locale";
import { Button } from "@/components/ui/button";
import { useToast } from "@/hooks/use-toast";
import { apiRequest } from "@/lib/queryClient";
import { useState, useEffect } from "react";
import { Input } from "@/components/ui/input";
import { Checkbox } from "@/components/ui/checkbox";
import useMqtt from "@/hooks/use-mqtt";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Progress } from "@/components/ui/progress";
import cn from 'classnames';

export default function SessionsPage() {
  const { data: cameras } = useQuery<Camera[]>({
    queryKey: ["/api/cameras"],
  });

  const { sensors } = useMqtt({
    host: 'mforum-livinglab', //Updated MQTT host
    port: import.meta.env.VITE_MQTT_PORT || '1883'
  });
  const { toast } = useToast();
  const queryClient = useQueryClient();

  // Estados para el formulario y búsqueda
  const [searchQuery, setSearchQuery] = useState("");
  const [sessionSearchQuery, setSessionSearchQuery] = useState("");
  const [selectedCameras, setSelectedCameras] = useState<number[]>([]);
  const [selectedSensors, setSelectedSensors] = useState<string[]>([]);
  const [sessionTitle, setSessionTitle] = useState("");
  const [isStarting, setIsStarting] = useState(false);
  const [viewSessionData, setViewSessionData] = useState<any>(null);

  // Estado para el contador de tiempo
  const [elapsedTime, setElapsedTime] = useState<{ [key: string]: number }>({});
  const [sessionStatus, setSessionStatus] = useState<{ [key: string]: string }>({});

  const { data: sessions, isLoading: isLoadingSessions } = useQuery({
    queryKey: ["/api/sessions"],
    refetchInterval: 5000, // Actualizar cada 5 segundos
  });

  // Filtrar sesiones basadas en la búsqueda
  const filteredSessions = sessions?.filter((session: any) => {
    if (!sessionSearchQuery) return true;
    return (
      session.title.toLowerCase().includes(sessionSearchQuery.toLowerCase()) ||
      session.id.toString().includes(sessionSearchQuery)
    );
  });

  // Actualizar contador de tiempo para sesiones activas
  useEffect(() => {
    const interval = setInterval(() => {
      if (sessions) {
        const newElapsedTime = { ...elapsedTime };
        const newStatus = { ...sessionStatus };

        sessions.forEach((session: any) => {
          const start = new Date(session.startTime).getTime();
          if (session.status === 'active') {
            newElapsedTime[session.id] = Math.floor((Date.now() - start) / 1000);
            newStatus[session.id] = 'active';
          } else if (session.status === 'completed') {
            const end = new Date(session.endTime).getTime();
            newElapsedTime[session.id] = Math.floor((end - start) / 1000);
            newStatus[session.id] = 'completed';
          }
        });

        setElapsedTime(newElapsedTime);
        setSessionStatus(newStatus);
      }
    }, 1000);

    return () => clearInterval(interval);
  }, [sessions]);

  // Formatear duración
  const formatTime = (seconds: number) => {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;
    return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
  };

  // Filtrar dispositivos basados en la búsqueda
  const filteredCameras = cameras?.filter(camera => {
    if (!searchQuery) return true;
    return camera.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
           camera.ipAddress.includes(searchQuery);
  }) || [];

  const filteredSensors = (sensors || []).filter((sensor: any) => {
    if (!searchQuery) return true;
    return (sensor.friendly_name || '').toLowerCase().includes(searchQuery.toLowerCase()) ||
           (sensor.ieee_addr || '').includes(searchQuery);
  });

  // Manejar selección de dispositivos
  const toggleCamera = (cameraId: number) => {
    setSelectedCameras(prev =>
      prev.includes(cameraId)
        ? prev.filter(id => id !== cameraId)
        : [...prev, cameraId]
    );
  };

  const handleSensorChange = (sensorId: string, checked: boolean) => {
    setSelectedSensors(prev => {
      if (checked) {
        return [...prev, sensorId];
      }
      return prev.filter(id => id !== sensorId);
    });
  };

  // Iniciar nueva sesión
  const startSession = async () => {
    if (!selectedCameras.length && !selectedSensors.length) {
      toast({
        title: "Error",
        description: "Selecciona al menos un dispositivo para iniciar la sesión",
        variant: "destructive",
      });
      return;
    }

    setIsStarting(true);
    try {
      const response = await apiRequest("POST", "/api/sessions", {
        title: sessionTitle || `Sesión ${format(new Date(), 'dd/MM/yyyy HH:mm')}`,
        devices: {
          cameras: selectedCameras.map(id => ({
            id,
            prefix: cameras?.find(c => c.id === id)?.recordingPrefix || `cam${id}`
          })),
          sensors: selectedSensors
        }
      });

      // Actualizar lista de grabaciones y sesiones
      await Promise.all([
        queryClient.invalidateQueries({ queryKey: ["/api/recordings"] }),
        queryClient.invalidateQueries({ queryKey: ["/api/sessions"] })
      ]);

      toast({
        title: "Sesión iniciada",
        description: "La grabación y captura de datos ha comenzado",
      });

      // Limpiar formulario
      setSelectedCameras([]);
      setSelectedSensors([]);
      setSessionTitle("");
    } catch (error) {
      toast({
        title: "Error",
        description: error instanceof Error ? error.message : "No se pudo iniciar la sesión",
        variant: "destructive",
      });
    } finally {
      setIsStarting(false);
    }
  };

  // Agregar nuevo estado para controlar la vista en cuadrícula
  const [isGridCollapsed, setIsGridCollapsed] = useState(false);
  const [isDeleteDialogOpen, setIsDeleteDialogOpen] = useState(false);
  const [sessionToDelete, setSessionToDelete] = useState<any>(null);

  // Función para manejar la eliminación de una sesión
  const handleDeleteSession = async (session: any) => {
    setSessionToDelete(session);
    setIsDeleteDialogOpen(true);
  };

  const confirmDeleteSession = async () => {
    if (!sessionToDelete) return;

    try {
      await apiRequest("DELETE", `/api/sessions/${sessionToDelete.id}`);

      // Actualizar la lista de sesiones y cámaras
      await Promise.all([
        queryClient.invalidateQueries({ queryKey: ["/api/sessions"] }),
        queryClient.invalidateQueries({ queryKey: ["/api/cameras"] })
      ]);

      toast({
        title: "Sesión eliminada",
        description: "La sesión se ha eliminado correctamente",
      });
    } catch (error) {
      toast({
        title: "Error",
        description: error instanceof Error ? error.message : "No se pudo eliminar la sesión",
        variant: "destructive",
      });
    } finally {
      setIsDeleteDialogOpen(false);
      setSessionToDelete(null);
    }
  };

  return (
    <div className="container mx-auto p-4 max-w-[1600px] space-y-6">
      {/* Nueva Sesión */}
      <div className="bg-card rounded-lg p-6 border">
        <div className="flex justify-between items-center mb-6">
          <h1 className="text-2xl font-bold">Nueva Sesión de Monitoreo</h1>
        </div>

        {/* Formulario de sesión */}
        <Card>
          <CardHeader>
            <CardTitle>Configuración de la Sesión</CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="flex items-center gap-4">
              <Input
                placeholder="Nombre de la sesión (opcional)"
                value={sessionTitle}
                onChange={(e) => setSessionTitle(e.target.value)}
                className="max-w-md"
              />
              <Button
                onClick={startSession}
                disabled={isStarting || (!selectedCameras.length && !selectedSensors.length)}
              >
                {isStarting ? (
                  <Loader2 className="h-4 w-4 animate-spin mr-2" />
                ) : (
                  <Play className="h-4 w-4 mr-2" />
                )}
                Iniciar Sesión
              </Button>
            </div>

            <div className="relative">
              <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground" />
              <Input
                placeholder="Buscar dispositivos..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                className="pl-9"
              />
            </div>
          </CardContent>
        </Card>

        {/* Lista de dispositivos */}
        <div className="grid gap-6 grid-cols-1 lg:grid-cols-2 mt-6">
          {/* Tabla de cámaras */}
          <Card>
            <CardHeader>
              <CardTitle>Cámaras Disponibles</CardTitle>
            </CardHeader>
            <CardContent>
              <Table>
                <TableHeader>
                  <TableRow>
                    <TableHead className="w-12"></TableHead>
                    <TableHead>Nombre</TableHead>
                    <TableHead>Dirección IP</TableHead>
                    <TableHead>Estado</TableHead>
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {filteredCameras.map((camera) => (
                    <TableRow key={camera.id}>
                      <TableCell>
                        <Checkbox
                          checked={selectedCameras.includes(camera.id)}
                          onCheckedChange={() => toggleCamera(camera.id)}
                        />
                      </TableCell>
                      <TableCell>{camera.name}</TableCell>
                      <TableCell>{camera.ipAddress}</TableCell>
                      <TableCell>
                        {camera.status === 'connected' ? (
                          <Check className="h-4 w-4 text-green-500" />
                        ) : (
                          <X className="h-4 w-4 text-red-500" />
                        )}
                      </TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </CardContent>
          </Card>

          {/* Tabla de sensores */}
          <Card>
            <CardHeader>
              <CardTitle>Sensores Disponibles</CardTitle>
            </CardHeader>
            <CardContent>
              <Table>
                <TableHeader>
                  <TableRow>
                    <TableHead className="w-12"></TableHead>
                    <TableHead>Nombre</TableHead>
                    <TableHead>ID</TableHead>
                    <TableHead>Estado</TableHead>
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {filteredSensors.map((sensor: any) => (
                    <TableRow key={sensor.ieee_addr}>
                      <TableCell>
                        <Checkbox
                          id={`sensor-${sensor.ieee_addr}`}
                          checked={selectedSensors.includes(sensor.ieee_addr)}
                          onCheckedChange={(checked) => {
                            if (typeof checked === 'boolean') {
                              handleSensorChange(sensor.ieee_addr, checked);
                            }
                          }}
                          disabled={sensor.status !== 'online'}
                        />
                      </TableCell>
                      <TableCell>{sensor.friendly_name || 'Sin nombre'}</TableCell>
                      <TableCell>{sensor.ieee_addr}</TableCell>
                      <TableCell>
                        {sensor.status === 'online' ? (
                          <Check className="h-4 w-4 text-green-500" />
                        ) : (
                          <X className="h-4 w-4 text-red-500" />
                        )}
                      </TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </CardContent>
          </Card>
        </div>
      </div>

      {/* Sesiones Activas */}
      <div className="bg-card rounded-lg p-6 border">
        <div className="flex justify-between items-center mb-6">
          <h2 className="text-xl font-semibold">Sesiones Activas</h2>
          <div className="flex items-center gap-4">
            <div className="relative max-w-sm">
              <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground" />
              <Input
                placeholder="Buscar sesiones..."
                value={sessionSearchQuery}
                onChange={(e) => setSessionSearchQuery(e.target.value)}
                className="pl-9"
              />
            </div>
            <Button
              variant="outline"
              size="sm"
              onClick={() => setIsGridCollapsed(!isGridCollapsed)}
            >
              {isGridCollapsed ? <ChevronDown className="h-4 w-4" /> : <ChevronUp className="h-4 w-4" />}
              {isGridCollapsed ? "Expandir" : "Contraer"}
            </Button>
          </div>
        </div>

        <div className={cn(
          "grid gap-4",
          isGridCollapsed ? "grid-cols-1 md:grid-cols-2 lg:grid-cols-3" : "grid-cols-1"
        )}>
          {filteredSessions?.map((session: any) => (
            <Card
              key={session.id}
              className={cn(
                session.status === 'active' ? 'border-green-500' :
                session.status === 'completed' ? 'border-blue-500' : 'border-gray-200',
                isGridCollapsed ? 'h-[300px] overflow-y-auto' : ''
              )}
            >
              <CardHeader>
                <div className="flex justify-between items-start">
                  <CardTitle>{session.title}</CardTitle>
                  <Button
                    variant="destructive"
                    size="sm"
                    onClick={() => handleDeleteSession(session)}
                  >
                    <Trash2 className="h-4 w-4" />
                  </Button>
                </div>
                <CardDescription>
                  Iniciada el {format(new Date(session.startTime), "PPpp", { locale: es })}
                  {session.status === 'completed' && session.endTime && (
                    <> - Finalizada el {format(new Date(session.endTime), "PPpp", { locale: es })}</>
                  )}
                </CardDescription>
              </CardHeader>
              <CardContent>
                <div className="space-y-4">
                  <div className="space-y-2">
                    <div>
                      <strong>Cámaras:</strong> {session.devices.cameras.length} seleccionadas
                    </div>
                    <div>
                      <strong>Sensores:</strong> {session.devices.sensors.length} seleccionados
                    </div>
                  </div>
                  <div className="space-y-2">
                    <div className="flex items-center justify-between">
                      <span className={cn(
                        "text-sm font-medium",
                        session.status === 'active' ? "text-green-600" :
                        session.status === 'completed' ? "text-blue-600" : "text-gray-600"
                      )}>
                        {session.status === 'active' ? 'Sesión en progreso' :
                         session.status === 'completed' ? 'Sesión finalizada' : 'Estado desconocido'}
                      </span>
                      <span className="text-sm text-muted-foreground">
                        {elapsedTime[session.id] ? formatTime(elapsedTime[session.id]) : '00:00:00'}
                      </span>
                    </div>
                    {session.status === 'active' && (
                      <Progress value={100} className="animate-pulse bg-green-100" />
                    )}
                  </div>
                </div>
              </CardContent>
              <CardFooter className="justify-end space-x-2">
                <Button
                  variant="outline"
                  onClick={() => setViewSessionData(session)}
                >
                  Ver Datos
                </Button>
                <Button
                  variant="outline"
                  onClick={async () => {
                    try {
                      const response = await fetch(`/api/sessions/${session.id}/download`);
                      if (!response.ok) throw new Error('Error al descargar');

                      const blob = await response.blob();
                      const url = window.URL.createObjectURL(blob);
                      const a = document.createElement('a');
                      a.href = url;
                      a.download = `session-${session.id}.zip`;
                      document.body.appendChild(a);
                      a.click();
                      document.body.removeChild(a);
                      window.URL.revokeObjectURL(url);
                    } catch (error) {
                      toast({
                        title: "Error",
                        description: "No se pudo descargar la sesión",
                        variant: "destructive",
                      });
                    }
                  }}
                >
                  <Download className="h-4 w-4 mr-2" />
                  Descargar
                </Button>
                {session.status === 'active' && (
                  <Button
                    variant="destructive"
                    onClick={async () => {
                      try {
                        await apiRequest("DELETE", `/api/sessions/${session.id}`);

                        // Actualizar la lista de sesiones y cámaras
                        await Promise.all([
                          queryClient.invalidateQueries({ queryKey: ["/api/sessions"] }),
                          queryClient.invalidateQueries({ queryKey: ["/api/cameras"] })
                        ]);

                        toast({
                          title: "Sesión finalizada",
                          description: "La sesión se ha detenido correctamente",
                        });
                      } catch (error) {
                        console.error('Error al finalizar sesión:', error);
                        toast({
                          title: "Error",
                          description: error instanceof Error ? error.message : "No se pudo finalizar la sesión",
                          variant: "destructive",
                        });
                      }
                    }}
                  >
                    Finalizar Sesión
                  </Button>
                )}
              </CardFooter>
            </Card>
          ))}
        </div>
      </div>

      {/* Diálogo de confirmación para eliminar sesión */}
      <Dialog open={isDeleteDialogOpen} onOpenChange={setIsDeleteDialogOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Confirmar eliminación</DialogTitle>
            <DialogDescription>
              ¿Estás seguro de que deseas eliminar esta sesión? Esta acción no se puede deshacer.
            </DialogDescription>
          </DialogHeader>
          <div className="flex justify-end space-x-2">
            <Button variant="outline" onClick={() => setIsDeleteDialogOpen(false)}>
              Cancelar
            </Button>
            <Button variant="destructive" onClick={confirmDeleteSession}>
              Eliminar
            </Button>
          </div>
        </DialogContent>
      </Dialog>

      {/* Diálogo para ver datos de la sesión */}
      <Dialog open={!!viewSessionData} onOpenChange={() => setViewSessionData(null)}>
        <DialogContent className="max-w-5xl max-h-[90vh] overflow-y-auto">
          <DialogHeader>
            <DialogTitle>Datos de la Sesión</DialogTitle>
            <DialogDescription>
              {viewSessionData?.title} - Iniciada el {viewSessionData && format(new Date(viewSessionData.startTime), "PPpp", { locale: es })}
            </DialogDescription>
          </DialogHeader>
          <div className="space-y-6">
            {/* Grabaciones de video */}
            <div>
              <h3 className="text-lg font-semibold mb-4">Grabaciones</h3>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                {viewSessionData?.devices.cameras.map((camera: any) => (
                  <div key={camera.id} className="border rounded-lg p-4">
                    <h4 className="font-medium mb-2">Cámara {camera.prefix || `cam${camera.id}`}</h4>
                    <video
                      controls
                      className="w-full aspect-video rounded-lg bg-black"
                      src={`/api/recordings/${camera.recordingId}/stream`}
                    />
                  </div>
                ))}
              </div>
            </div>

            {/* Datos de sensores */}
            {viewSessionData?.devices.sensors.length > 0 && (
              <div>
                <h3 className="text-lg font-semibold mb-4">Datos de Sensores</h3>
                <div className="grid gap-4">
                  {viewSessionData.devices.sensors.map((sensorId: string) => (
                    <div key={sensorId} className="border rounded-lg p-4">
                      <h4 className="font-medium mb-2">Sensor {sensorId}</h4>
                      <pre className="bg-muted p-4 rounded-lg overflow-auto max-h-60">
                        {JSON.stringify(viewSessionData.sensorData?.[sensorId] || [], null, 2)}
                      </pre>
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>
        </DialogContent>
      </Dialog>
    </div>
  );
}