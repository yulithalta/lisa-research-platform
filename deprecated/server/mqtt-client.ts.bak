import * as mqtt from 'mqtt';
import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';
import { dirname } from 'path';
import { logger } from '../client/src/lib/services/logger';

// Obtener la ruta del directorio actual en módulos ES
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Definir la ruta para las sesiones
const SESSIONS_DIR = path.join(__dirname, '../sessions');

class MQTTClient {
  private static instance: MQTTClient;
  private client: mqtt.MqttClient | null = null;
  private activeSessions: Map<string, string[]> = new Map(); // sessionId -> sensorIds
  private detectedDevices: Set<string> = new Set(); // Almacena IDs de dispositivos detectados
  private deviceDetails: Map<string, any> = new Map(); // Almacena detalles completos de dispositivos
  
  private constructor() {
    // Singleton
  }
  
  public static getInstance(): MQTTClient {
    if (!MQTTClient.instance) {
      MQTTClient.instance = new MQTTClient();
    }
    return MQTTClient.instance;
  }
  
  // Método para obtener los dispositivos detectados
  public getDetectedDevices(): any[] {
    const devices = [];
    // Convertir los dispositivos almacenados a un formato útil para la API
    this.detectedDevices.forEach(deviceId => {
      const details = this.deviceDetails.get(deviceId) || {};
      devices.push({
        id: deviceId,
        topic: details.topic || `zigbee2mqtt/${deviceId}`,
        lastSeen: details.timestamp || new Date().toISOString(),
        type: details.type || 'unknown',
        data: details.data || {}
      });
    });
    return devices;
  }
  
  public isConnected(): boolean {
    return this.client !== null && this.client.connected;
  }
  
  public async connect(host: string = process.env.VITE_MQTT_HOST || '192.168.0.20', port: string = process.env.VITE_MQTT_PORT || '1883'): Promise<void> {
    try {
      // Crear directorio de sesiones si no existe
      if (!fs.existsSync(SESSIONS_DIR)) {
        fs.mkdirSync(SESSIONS_DIR, { recursive: true });
      }
      
      // Usar la dirección del servidor MQTT proporcionada
      const url = `mqtt://${host}:${port}`;
      logger.info(`Connecting to MQTT broker at ${url}`);
      
      // Intentar conectar con el broker MQTT sin credenciales para entorno de testing
      logger.info(`Intentando conectar a broker MQTT en ${host}:${port} sin credenciales...`);
      
      this.client = mqtt.connect(url, {
        clientId: `server_${Math.random().toString(16).substr(2, 8)}`,
        clean: true,
        reconnectPeriod: 5000,
        connectTimeout: 30 * 1000
      });
      
      // Agregar un evento para manejar fallos de conexión y probar puertos alternativos
      this.client.on('error', (err) => {
        logger.error(`Error connecting to MQTT broker at ${url}:`, err);
        
        // Si falla el puerto principal, intentar con puerto alternativo (WebSocket)
        if (port === '1883' && !this.client?.connected) {
          const wsPort = '9001';
          const wsUrl = `ws://${host}:${wsPort}`;
          logger.info(`Intentando conectar a broker MQTT WebSocket en ${wsUrl}...`);
          
          try {
            // Cerrar cliente anterior si existe
            if (this.client) {
              this.client.end(true);
            }
            
            // Intentar con WebSocket
            this.client = mqtt.connect(wsUrl, {
              clientId: `server_ws_${Math.random().toString(16).substr(2, 8)}`,
              clean: true,
              reconnectPeriod: 5000,
              connectTimeout: 30 * 1000
            });
          } catch (wsErr) {
            logger.error(`Error connecting to MQTT WebSocket broker at ${wsUrl}:`, wsErr);
          }
        }
      });
      
      this.client.on('connect', () => {
        logger.info('Connected to MQTT broker');
        
        // Suscribirse a todos los topics de zigbee2mqtt con comodín para capturar todos los dispositivos
        // Esto usará un patrón Observer distribuido para capturar automáticamente cualquier sensor nuevo sin cambios en el código
        this.client.subscribe('zigbee2mqtt/#', { qos: 1 }, (err) => {
          if (err) {
            logger.error('Error subscribing to Zigbee2MQTT wildcard topic:', err);
          } else {
            logger.info('Subscribed to all Zigbee2MQTT topics using wildcard pattern');
          }
        });
        
        // Suscribirse específicamente al topic especial para dispositivos
        this.client.subscribe('zigbee2mqtt/livinglab/device', { qos: 1 }, (err) => {
          if (err) {
            logger.error('Error subscribing to Zigbee2MQTT device topic:', err);
          } else {
            logger.info('Subscribed to Zigbee2MQTT livinglab device topic');
          }
        });
      });
      
      this.client.on('message', async (topic, message) => {
        await this.handleMessage(topic, message);
      });
      
      // El evento 'error' ya está configurado arriba para el fallback
      
      this.client.on('close', () => {
        logger.info('MQTT client disconnected');
      });
    } catch (err) {
      logger.error('Error connecting to MQTT broker:', err);
      throw err;
    }
  }
  
  // Método para analizar los datos de un sensor y guardarlos para las sesiones activas
  private saveSensorData(topic: string, payload: any): void {
    try {
      // Buscamos el ID del sensor basado en diferentes patrones de topic
      let sensorId = '';
      const topicParts = topic.split('/');
      
      // CASO ESPECIAL: Si el topic es "zigbee2mqtt/bridge/devices" - Contiene lista de dispositivos
      if (topic.includes('bridge/devices') && Array.isArray(payload)) {
        // Procesamos cada dispositivo en la lista
        payload.forEach((device: any) => {
          if (device && device.ieee_address) {
            const deviceId = device.ieee_address;
            
            // Guardar para todas las sesiones interesadas en este dispositivo
            this.activeSessions.forEach((sensorIds, sessionId) => {
              if (sensorIds.includes(deviceId) || sensorIds.includes('ALL_TOPICS')) {
                // Guardar en formato estándar
                this.saveData(sessionId, deviceId, {
                  topic: topic,
                  device: device,
                  timestamp: new Date().toISOString()
                });
                
                // También crear/actualizar un archivo de datos consolidados para la sesión
                this.updateSessionSensorData(sessionId, deviceId, {
                  device: device,
                  lastSeen: new Date().toISOString(),
                  info: device
                });
                
                logger.info(`✅ Dispositivo ${deviceId} registrado en sesión ${sessionId}`);
              }
            });
          }
        });
        return;
      }
      
      // CASO ESPECIAL: Si el topic contiene información de sensores específicos
      if (topic.includes('sensors_compatible') || topic.includes('simple_sensors')) {
        // Procesar cada sensor en el objeto
        Object.entries(payload).forEach(([deviceId, data]) => {
          // Para cada sesión interesada en este sensor
          this.activeSessions.forEach((sensorIds, sessionId) => {
            if (sensorIds.includes(deviceId) || sensorIds.includes('ALL_TOPICS')) {
              // Guardar en formato estándar 
              this.saveData(sessionId, deviceId, {
                topic: topic,
                data: data,
                timestamp: new Date().toISOString()
              });
              
              // Actualizar también el archivo consolidado
              this.updateSessionSensorData(sessionId, deviceId, {
                lastSeen: new Date().toISOString(),
                data: data,
                topic: topic
              });
              
              logger.info(`✅ Datos del sensor ${deviceId} actualizados en sesión ${sessionId}`);
            }
          });
        });
        return;
      }
      
      // CASO NORMAL: Identificar sensor por su IEEE address en el topic
      // Buscar si hay alguna dirección IEEE (0x...) en el topic
      const ieeeRegex = /0x[0-9a-fA-F]{16}/;
      const ieeeMatch = topic.match(ieeeRegex);
      
      if (ieeeMatch) {
        sensorId = ieeeMatch[0];
      } 
      // O si el topic contiene directamente un sensorId que conocemos
      else {
        // Intentar extraer un ID basado en el formato del topic
        if (topicParts.length >= 2 && topicParts[0] === 'zigbee2mqtt') {
          // zigbee2mqtt/sensorId
          if (topicParts.length === 2) {
            sensorId = topicParts[1];
          }
          // zigbee2mqtt/livinglab/sensorId
          else if (topicParts.length >= 3) {
            // Probar con varios formatos posibles
            const possibleIds = [
              topicParts[2],
              `${topicParts[1]}/${topicParts[2]}`,
              topicParts.slice(1).join('/')
            ];
            
            // Ver si alguno de los IDs posibles está en nuestras sesiones
            let found = false;
            for (const possibleId of possibleIds) {
              // Buscar en todas las sesiones activas
              this.activeSessions.forEach((sensorIds, sessionId) => {
                if (sensorIds.includes(possibleId) || sensorIds.includes('ALL_TOPICS')) {
                  found = true;
                  
                  // Guardar datos para este sensor
                  this.saveData(sessionId, possibleId, {
                    topic: topic, 
                    data: payload,
                    timestamp: new Date().toISOString()
                  });
                  
                  // Actualizar archivo consolidado
                  this.updateSessionSensorData(sessionId, possibleId, {
                    lastSeen: new Date().toISOString(),
                    data: payload,
                    topic: topic
                  });
                  
                  logger.info(`✅ Datos guardados para ${possibleId} en sesión ${sessionId}`);
                }
              });
              
              if (found) break;
            }
            
            // Si encontramos un match, ya terminamos el procesamiento
            if (found) return;
            
            // Si no encontramos match, usar el ID más específico
            sensorId = topicParts[2] || topicParts[1];
          }
        } 
        // Topics que empiezan con 0x (direcciones IEEE)
        else if (topicParts.length >= 1 && topicParts[0].startsWith('0x')) {
          sensorId = topicParts[0];
        }
      }
      
      // Si no pudimos extraer un ID, usar el topic como identificador
      if (!sensorId) {
        sensorId = topic.replace(/[\/\+\#]/g, '_');
      }
      
      // Guardar para cada sesión activa interesada en este sensor
      this.activeSessions.forEach((sensorIds, sessionId) => {
        if (sensorIds.includes(sensorId) || sensorIds.includes('ALL_TOPICS')) {
          // Guardar en formato estándar
          this.saveData(sessionId, sensorId, {
            topic: topic,
            data: payload,
            timestamp: new Date().toISOString()
          });
          
          // Actualizar archivo consolidado
          this.updateSessionSensorData(sessionId, sensorId, {
            lastSeen: new Date().toISOString(),
            data: payload,
            topic: topic
          });
          
          logger.info(`✅ Datos del sensor ${sensorId} en topic ${topic} actualizados para sesión ${sessionId}`);
        }
      });
      
    } catch (err) {
      logger.error(`Error procesando datos del sensor en topic ${topic}:`, err);
    }
  }
  
  // Método para actualizar el archivo JSON consolidado de una sesión
  private updateSessionSensorData(sessionId: string, sensorId: string, data: any): void {
    try {
      if (!sessionId || !sensorId) return;
      
      // Normalizar sessionId para rutas de archivo
      const safeSessionId = sessionId.replace(/[^a-z0-9_-]/gi, '_');
      const sessionDir = path.join(SESSIONS_DIR, `Session${safeSessionId}`);
      
      // Asegurar que existe el directorio
      if (!fs.existsSync(sessionDir)) {
        fs.mkdirSync(sessionDir, { recursive: true });
      }
      
      // Ruta al archivo de datos consolidados
      const consolidatedDataPath = path.join(sessionDir, 'session_data.json');
      
      // Leer datos existentes o crear nuevo objeto
      let sessionData: any = {
        sessionId: sessionId,
        sensors: {},
        lastUpdated: new Date().toISOString()
      };
      
      // Si el archivo existe, leer su contenido
      if (fs.existsSync(consolidatedDataPath)) {
        try {
          const content = fs.readFileSync(consolidatedDataPath, 'utf-8');
          if (content.trim() !== '') {
            sessionData = JSON.parse(content);
          }
        } catch (readErr) {
          logger.error(`Error leyendo archivo consolidado para sesión ${sessionId}:`, readErr);
        }
      }
      
      // Asegurar que la estructura es correcta
      if (!sessionData.sensors) {
        sessionData.sensors = {};
      }
      
      // Actualizar o crear datos del sensor
      if (!sessionData.sensors[sensorId]) {
        sessionData.sensors[sensorId] = {
          id: sensorId,
          data: [],
          createdAt: new Date().toISOString()
        };
      }
      
      // Añadir el nuevo dato con timestamp
      const sensorData = {
        ...data,
        timestamp: data.timestamp || new Date().toISOString()
      };
      
      // Añadir a la lista de datos, limitando a 200 entradas para evitar archivos enormes
      sessionData.sensors[sensorId].data = [
        ...(Array.isArray(sessionData.sensors[sensorId].data) ? 
          sessionData.sensors[sensorId].data.slice(-199) : []),
        sensorData
      ];
      
      // Actualizar timestamp
      sessionData.sensors[sensorId].lastUpdated = new Date().toISOString();
      sessionData.lastUpdated = new Date().toISOString();
      
      // Guardar archivo
      fs.writeFileSync(consolidatedDataPath, JSON.stringify(sessionData, null, 2));
      
    } catch (err) {
      logger.error(`Error actualizando datos consolidados para sesión ${sessionId}, sensor ${sensorId}:`, err);
    }
  }
  
  private async handleMessage(topic: string, message: Buffer): Promise<void> {
    // Ignorar tópicos de sistema no necesarios para el funcionamiento del Observer Pattern
    // pero mantenemos los topics de dispositivos que pueden tener información importante
    if (topic.includes('bridge/') && !topic.includes('bridge/devices')) {
      return;
    }
    
    try {
      // Intentar parsear el mensaje como JSON
      let payload: any;
      let payloadString: string;
      
      try {
        payloadString = message.toString();
        payload = JSON.parse(payloadString);
        
        // Añadir al mapa de sensores para acceso offline
        const { sensorDataMapper } = await import('./sensor-data-mapper');
        sensorDataMapper.addSensorFromMqttTopic(topic, payload);
        
        // Si hay sesiones activas, guardar los datos para cada sensor pertinente
        if (this.activeSessions.size > 0) {
          this.saveSensorData(topic, payload);
          
          // Guardar todos los mensajes MQTT en CSV para cada sesión activa
          this.appendToAllDataCSV(topic, payloadString);
        }
      } catch (e) {
        // Si no es JSON, usar el mensaje crudo
        payloadString = message.toString();
        payload = { raw: payloadString };
        
        // Aún guardar datos no-JSON en sesiones activas como texto
        if (this.activeSessions.size > 0) {
          logger.info(`Mensaje no-JSON recibido en topic: ${topic}`);
          this.saveSensorData(topic, payload);
          
          // Guardar todos los mensajes MQTT en CSV para cada sesión activa
          this.appendToAllDataCSV(topic, payloadString);
        }
      }
      
      // Método para añadir información al CSV de todas las sesiones activas
      
    } catch (error) {
      logger.error(`Error processing MQTT message on topic ${topic}:`, error);
    }
      
      // Extraer y registrar dispositivo para su posterior descubrimiento
      // Esto permite que cualquier dispositivo que publique en MQTT sea detectado automáticamente
      const topicParts = topic.split('/');
      if (topicParts.length >= 2 && topicParts[0] === 'zigbee2mqtt') {
        let deviceId = '';
        
        // Formato común zigbee2mqtt/deviceId
        if (topicParts.length === 2) {
          deviceId = topicParts[1];
        } 
        // Formato anidado zigbee2mqtt/livinglab/deviceId
        else if (topicParts.length >= 3) {
          deviceId = topicParts.slice(1).join('/');
        }
        
        if (deviceId && deviceId !== 'bridge') {
          // Registrar este dispositivo para descubrimiento
          this.detectedDevices.add(deviceId);
          
          // Almacenar detalles adicionales sobre el dispositivo
          this.deviceDetails.set(deviceId, {
            topic,
            timestamp: new Date().toISOString(),
            type: topic.includes('sensor') ? 'sensor' : 
                  topic.includes('device') ? 'device' : 'unknown',
            data: payload
          });
          
          // Log para depuración
          logger.info(`Dispositivo Zigbee detectado y registrado: ${deviceId}`);
        }
      }
      
      // Si hay alguna sesión que esté capturando todos los topics, guardar este mensaje
      // sin importar el formato o el origen
      this.activeSessions.forEach((sensorIds, sessionId) => {
        if (sensorIds.includes('ALL_TOPICS')) {
          // Capturar todo el tráfico MQTT para esta sesión
          this.saveData(sessionId, topic.replace(/[\/\+\#]/g, '_'), {
            topic,
            timestamp: new Date().toISOString(),
            payload
          });
          logger.info(`Datos MQTT de topic ${topic} guardados para sesión ${sessionId} (modo captura completa)`);
          return; // Continuar con la siguiente sesión
        }
      });
      
      // Extraer el ID del sensor del topic (zigbee2mqtt/sensorId o zigbee2mqtt/livinglab/sensorId)
      const sensorTopicParts = topic.split('/');
      if (sensorTopicParts.length < 2) {
        logger.info(`MQTT topic no tiene formato esperado: ${topic}`);
        return;
      }
      
      // Adaptación para varios formatos posibles de topic
      // 1. zigbee2mqtt/sensorId (formato común)
      // 2. zigbee2mqtt/livinglab/sensorId (formato usado en algunos sistemas)
      // 3. zigbee2mqtt/Nuevo-s5-Rosa (formato personalizado)
      // 4. zigbee2mqtt/livinglab/device (topic especial)
      
      let sensorId = '';
      
      if (sensorTopicParts.length >= 2) {
        if (sensorTopicParts.length === 2) {
          // Caso: zigbee2mqtt/sensorId
          sensorId = sensorTopicParts[1];
        } else if (sensorTopicParts.length === 3) {
          // Caso: zigbee2mqtt/livinglab/device o zigbee2mqtt/livinglab/sensorId
          // Usar la estructura completa como identificador para no perder información
          sensorId = `${sensorTopicParts[1]}/${sensorTopicParts[2]}`;
        } else if (sensorTopicParts.length > 3) {
          // Caso de topic muy anidado - usar todo excepto "zigbee2mqtt"
          sensorId = sensorTopicParts.slice(1).join('/');
        }
      }
      
      // Verificar que el ID del sensor es válido
      if (!sensorId || typeof sensorId !== 'string' || sensorId.trim() === '') {
        logger.info(`ID de sensor inválido en topic MQTT: ${topic}`);
        return;
      }
      
      // Log de depuración para ver qué datos estamos recibiendo
      logger.info(`Topic MQTT recibido: ${topic}, ID extraído: ${sensorId}`);
      
      // Si no hay sesiones activas pero recibimos datos, lo registramos sin guardar
      if (this.activeSessions.size === 0) {
        logger.info(`Datos MQTT recibidos (sin sesiones activas): ${topic}`);
      }
      
      // Verificar si este sensor está siendo monitoreado en alguna sesión activa
      let sensorMonitored = false;
      
      // Guardar datos para todas las sesiones activas que usan este sensor
      this.activeSessions.forEach((sensorIds, sessionId) => {
        // Solo registrar datos si el sensorId está en la lista de sensores de la sesión
        // y la lista de sensores es válida (array no vacío)
        if (Array.isArray(sensorIds) && sensorIds.length > 0 && sensorIds.includes(sensorId)) {
          sensorMonitored = true;
          this.saveData(sessionId, sensorId, {
            topic,
            timestamp: new Date().toISOString(),
            payload
          });
        }
      });
      
      if (sensorMonitored) {
        logger.info(`Datos recibidos para sensor ${sensorId} guardados en sesiones activas`);
      }
    } catch (err) {
      logger.error('Error processing MQTT message:', err);
    }
  }
  
  private saveData(sessionId: string, sensorId: string, data: any): void {
    try {
      if (!sessionId || typeof sessionId !== 'string' || !sensorId || typeof sensorId !== 'string') {
        logger.error(`saveData recibió parámetros inválidos: sessionId=${sessionId}, sensorId=${sensorId}`);
        return;
      }
      
      // Normalizar los IDs para evitar problemas con caracteres especiales en nombres de archivo
      const safeSessionId = sessionId.replace(/[^a-z0-9_-]/gi, '_');
      const safeSensorId = sensorId.replace(/[^a-z0-9_-]/gi, '_');
      
      const sessionDir = path.join(SESSIONS_DIR, `Session${safeSessionId}`);
      const sensorDataPath = path.join(sessionDir, 'sensor_data');
      const sensorFile = path.join(sensorDataPath, `${safeSensorId}.json`);
      
      // Asegurar que los directorios existen
      if (!fs.existsSync(sessionDir)) {
        fs.mkdirSync(sessionDir, { recursive: true });
        logger.info(`Creado directorio de sesión: ${sessionDir}`);
      }
      
      if (!fs.existsSync(sensorDataPath)) {
        fs.mkdirSync(sensorDataPath, { recursive: true });
        logger.info(`Creado directorio de datos de sensores: ${sensorDataPath}`);
      }
      
      // Leer datos existentes con manejo de errores mejorado
      let existingData: any[] = [];
      if (fs.existsSync(sensorFile)) {
        try {
          const content = fs.readFileSync(sensorFile, 'utf-8');
          if (content.trim() === '') {
            // Si el archivo está vacío, inicializarlo con un array vacío
            existingData = [];
          } else {
            // Intentar parsear el contenido como JSON
            existingData = JSON.parse(content);
            
            // Validar que lo leído es un array
            if (!Array.isArray(existingData)) {
              logger.error(`El archivo ${sensorFile} no contiene un array JSON válido. Se reiniciará.`);
              existingData = [];
            }
          }
        } catch (err) {
          logger.error(`Error reading sensor data file for ${sensorId}:`, err);
          // Si hay error al leer el archivo, reiniciar con array vacío
          existingData = [];
        }
      }
      
      // Formatear y añadir nuevo dato con timestamp en formato ISO para mejor compatibilidad
      if (data && typeof data === 'object') {
        // Asegurar que tiene timestamp
        if (!data.timestamp) {
          data.timestamp = new Date().toISOString();
        }
        
        // Añadir nuevo dato
        existingData.push(data);
        
        // Limitar a 1000 entradas por archivo para evitar archivos enormes
        if (existingData.length > 1000) {
          existingData = existingData.slice(-1000);
        }
        
        // Guardar datos actualizados en archivo individual
        fs.writeFileSync(sensorFile, JSON.stringify(existingData, null, 2));
        
        // También actualizar el archivo de datos consolidado de la sesión
        this.updateSessionDataFile(sessionId, sensorId, data);
        
        logger.info(`✅ Datos del sensor ${sensorId} guardados en sesión ${sessionId}`);
      } else {
        logger.error(`Dato inválido para sensor ${sensorId}:`, data);
      }
    } catch (err) {
      logger.error(`Error saving sensor data for ${sensorId} in session ${sessionId}:`, err);
    }
  }
  
  // Registrar una sesión para recibir datos de sensores
  public registerSession(sessionId: string, sensorIds: string[]): void {
    // Validación de parámetros
    if (!sessionId || typeof sessionId !== 'string') {
      logger.error(`ID de sesión inválido: ${sessionId}`);
      return;
    }
    
    // Verificar que sensorIds es un array válido
    if (!Array.isArray(sensorIds)) {
      logger.info(`Lista de sensores no válida para la sesión ${sessionId}`);
      return;
    }
    
    // Crear archivo CSV para capturar todo el tráfico MQTT de esta sesión
    try {
      const safeSessionId = sessionId.replace(/[^a-z0-9_-]/gi, '_');
      const sessionDir = path.join(SESSIONS_DIR, `Session${safeSessionId}`);
      
      // Asegurar que los directorios existen
      if (!fs.existsSync(sessionDir)) {
        fs.mkdirSync(sessionDir, { recursive: true });
        logger.info(`Created session directory: ${sessionDir}`);
      }
      
      // Crear archivo CSV con cabecera
      const csvFilePath = path.join(sessionDir, 'all_data.csv');
      const csvHeader = 'timestamp,topic,payload\n';
      fs.writeFileSync(csvFilePath, csvHeader);
      logger.info(`Created CSV file for all MQTT traffic: ${csvFilePath}`);
    } catch (err) {
      logger.error(`Error creating CSV file for session ${sessionId}:`, err);
    }
    
    // Si no hay sensores específicos, se asume que queremos capturar todos los topics
    // Este caso es importante para permitir que una sesión capture todos los datos
    if (sensorIds.length === 0) {
      logger.info(`Session ${sessionId} configured to capture all MQTT topics`);
      // Registrar un sensor especial que indica la captura de todos los topics
      this.activeSessions.set(sessionId, ['ALL_TOPICS']);
      return;
    }
    
    // Filtrar sensorIds para asegurar que solo contenga strings válidos
    const validSensorIds = sensorIds.filter(id => id && typeof id === 'string' && id.trim() !== '');
    
    if (!validSensorIds.length) {
      logger.error(`No hay IDs de sensores válidos para la sesión ${sessionId}`);
      return;
    }
    
    // Normalizar sessionId para uso en rutas de archivos
    const safeSessionId = sessionId.replace(/[^a-z0-9_-]/gi, '_');
    
    logger.info(`Registrando sesión ${sessionId} para sensores: ${validSensorIds.join(', ')}`);
    this.activeSessions.set(sessionId, validSensorIds);
    
    // Inicializar archivos de datos para cada sensor
    const sessionDir = path.join(SESSIONS_DIR, `Session${safeSessionId}`);
    const sensorDataPath = path.join(sessionDir, 'sensor_data');
    
    // Crear directorios si no existen
    if (!fs.existsSync(sessionDir)) {
      fs.mkdirSync(sessionDir, { recursive: true });
      logger.info(`Creado directorio para sesión: ${sessionDir}`);
    }
    
    if (!fs.existsSync(sensorDataPath)) {
      fs.mkdirSync(sensorDataPath, { recursive: true });
      logger.info(`Creado directorio para datos de sensores: ${sensorDataPath}`);
    }
    
    // Crear archivos de datos iniciales para cada sensor
    for (const sensorId of validSensorIds) {
      const safeSensorId = sensorId.replace(/[^a-z0-9_-]/gi, '_');
      const sensorFile = path.join(sensorDataPath, `${safeSensorId}.json`);
      
      if (!fs.existsSync(sensorFile)) {
        fs.writeFileSync(sensorFile, '[]');
        logger.info(`Inicializado archivo de datos para sensor ${sensorId} en sesión ${sessionId}`);
      } else {
        logger.info(`El archivo de datos para sensor ${sensorId} ya existe en sesión ${sessionId}`);
      }
    }
    
    // Crear archivo de resumen de sensores registrados
    try {
      const sessionInfoFile = path.join(sessionDir, 'session_info.json');
      const sessionInfo = {
        sessionId,
        registeredAt: new Date().toISOString(),
        sensors: validSensorIds,
        status: 'active'
      };
      fs.writeFileSync(sessionInfoFile, JSON.stringify(sessionInfo, null, 2));
      logger.info(`Información de sesión guardada en: ${sessionInfoFile}`);
    } catch (err) {
      logger.error(`Error al guardar información de sesión: ${sessionId}`, err);
    }
  }
  
  // Desregistrar una sesión cuando termina
  public unregisterSession(sessionId: string): void {
    if (!sessionId || typeof sessionId !== 'string') {
      logger.error(`ID de sesión inválido para desregistrar: ${sessionId}`);
      return;
    }
    
    // Normalizar sessionId para uso en rutas de archivos
    const safeSessionId = sessionId.replace(/[^a-z0-9_-]/gi, '_');
    
    if (this.activeSessions.has(sessionId)) {
      logger.info(`Desregistrando sesión ${sessionId}`);
      
      // Actualizar archivo de información de sesión para marcarla como completada
      try {
        const sessionDir = path.join(SESSIONS_DIR, `Session${safeSessionId}`);
        const sessionInfoFile = path.join(sessionDir, 'session_info.json');
        
        if (fs.existsSync(sessionInfoFile)) {
          let sessionInfo: any = {};
          
          try {
            const content = fs.readFileSync(sessionInfoFile, 'utf-8');
            sessionInfo = JSON.parse(content);
          } catch (err) {
            logger.error(`Error leyendo archivo de información de sesión ${sessionId}:`, err);
            sessionInfo = {
              sessionId,
              sensors: this.activeSessions.get(sessionId) || []
            };
          }
          
          // Actualizar estado y tiempo de finalización
          sessionInfo.status = 'completed';
          sessionInfo.completedAt = new Date().toISOString();
          
          // Escribir archivo actualizado
          fs.writeFileSync(sessionInfoFile, JSON.stringify(sessionInfo, null, 2));
          logger.info(`Sesión ${sessionId} marcada como completada en ${sessionInfoFile}`);
        } else {
          logger.warn(`No se encontró archivo de información para sesión ${sessionId} en ${sessionInfoFile}`);
        }
      } catch (err) {
        logger.error(`Error al actualizar estado de sesión ${sessionId}:`, err);
      }
      
      // Eliminar de sesiones activas
      this.activeSessions.delete(sessionId);
      logger.info(`Sesión ${sessionId} eliminada de sesiones activas`);
    } else {
      logger.warn(`Intento de desregistrar sesión inexistente: ${sessionId}`);
    }
  }
  
  // Método para mantener actualizado el archivo de datos consolidado de la sesión
  private updateSessionDataFile(sessionId: string, sensorId: string, newData: any): void {
    try {
      // Normalizar sessionId para rutas de archivo
      const safeSessionId = sessionId.replace(/[^a-z0-9_-]/gi, '_');
      const sessionDir = path.join(SESSIONS_DIR, `Session${safeSessionId}`);
      
      // Ruta al archivo de datos consolidados
      const sessionDataPath = path.join(sessionDir, 'session_data.json');
      
      // Si el archivo no existe, inicializarlo con estructura básica
      if (!fs.existsSync(sessionDataPath)) {
        // Estructura básica para el archivo
        const initialData = {
          sessionId,
          title: `Sesión ${new Date().toLocaleDateString()}`,
          startTime: new Date().toISOString(),
          sensors: {},
          lastUpdated: new Date().toISOString()
        };
        
        // Crear el archivo
        fs.writeFileSync(sessionDataPath, JSON.stringify(initialData, null, 2));
        logger.info(`Inicializado archivo de datos para sesión ${sessionId}`);
      }
      
      // Leer el archivo existente
      let sessionData: any = {};
      try {
        const fileContent = fs.readFileSync(sessionDataPath, 'utf8');
        sessionData = JSON.parse(fileContent);
      } catch (readErr) {
        logger.error(`Error leyendo archivo de datos de sesión ${sessionId}:`, readErr);
        // Inicializar con estructura básica si hay error
        sessionData = {
          sessionId,
          title: `Sesión ${new Date().toLocaleDateString()}`,
          startTime: new Date().toISOString(),
          sensors: {},
          lastUpdated: new Date().toISOString()
        };
      }
      
      // Asegurarnos que existe la estructura para este sensor
      if (!sessionData.sensors) {
        sessionData.sensors = {};
      }
      
      if (!sessionData.sensors[sensorId]) {
        sessionData.sensors[sensorId] = {
          id: sensorId,
          data: [],
          createdAt: new Date().toISOString()
        };
      }
      
      // Asegurarnos que data es un array
      if (!Array.isArray(sessionData.sensors[sensorId].data)) {
        sessionData.sensors[sensorId].data = [];
      }
      
      // Añadir el nuevo dato
      sessionData.sensors[sensorId].data.push({
        ...newData,
        timestamp: newData.timestamp || new Date().toISOString()
      });
      
      // Limitar el número de datos para no hacer el archivo demasiado grande
      const MAX_DATA_POINTS = 100;
      if (sessionData.sensors[sensorId].data.length > MAX_DATA_POINTS) {
        sessionData.sensors[sensorId].data = sessionData.sensors[sensorId].data.slice(-MAX_DATA_POINTS);
      }
      
      // Actualizar timestamps
      sessionData.sensors[sensorId].lastUpdated = new Date().toISOString();
      sessionData.lastUpdated = new Date().toISOString();
      
      // Guardar archivo actualizado
      fs.writeFileSync(sessionDataPath, JSON.stringify(sessionData, null, 2));
      
    } catch (err) {
      logger.error(`Error actualizando archivo de datos consolidados para sesión ${sessionId}:`, err);
    }
  }

  // Desconectar el cliente MQTT
  public disconnect(): void {
    if (this.client) {
      this.client.end();
      this.client = null;
    }
  }
  
  // Los métodos de simulación han sido eliminados para garantizar
  // que el sistema solo utilice conexiones reales a dispositivos en entornos clínicos.
  private simulateMQTTClient(): void {
    logger.error('La simulación de MQTT ha sido deshabilitada. El sistema requiere una conexión real a un broker MQTT.');
    throw new Error('MQTT simulation disabled - real broker required');
  }
  
  // Método para simular mensajes periódicos de sensores (sustituido)
  private startSimulatedSensors(): void {
    logger.error('La simulación de sensores ha sido deshabilitada. El sistema requiere sensores reales.');
    throw new Error('Sensor simulation disabled - real sensors required');
  }
}

const mqttClient = MQTTClient.getInstance();
export { mqttClient };
  // Método para agregar datos al archivo CSV que captura todo el tráfico MQTT
  private appendToAllDataCSV(topic: string, payload: string): void {
    try {
      // Para cada sesión activa, agregar los datos al CSV
      this.activeSessions.forEach((sensorIds, sessionId) => {
        const safeSessionId = sessionId.replace(/[^a-z0-9_-]/gi, '_');
        const sessionDir = path.join(SESSIONS_DIR, `Session${safeSessionId}`);
        const csvFilePath = path.join(sessionDir, 'all_data.csv');
        
        // Verificar si el archivo existe
        if (fs.existsSync(csvFilePath)) {
          // Formatear el payload para CSV (escapar comillas y añadir comillas alrededor)
          const timestamp = new Date().toISOString();
          const escapedPayload = payload.replace(/"/g, '""');
          const csvLine = `${timestamp},"${topic}","${escapedPayload}"\n`;
          
          // Agregar nueva línea al archivo CSV
          fs.appendFileSync(csvFilePath, csvLine);
        }
      });
    } catch (err) {
      logger.error('Error appending to all_data.csv:', err);
    }
  }
