# Gu√≠a para implementar el sistema de identificaci√≥n √∫nico en nuevas sesiones

Vamos a implementar una soluci√≥n que asegure que cada sesi√≥n tenga un identificador √∫nico y que todos los archivos generados durante esa sesi√≥n compartan ese identificador. Esto mejorar√° significativamente la seguridad y evitar√° que se mezclen datos entre sesiones.

## 1. Archivos a modificar

Basado en el c√≥digo que me mostraste, necesitamos modificar estos componentes:

1. **`session.service.ts`** - Para generar y gestionar el hash √∫nico de sesi√≥n
2. **`routes.ts`** - Espec√≠ficamente donde se crea una nueva sesi√≥n 
3. **`startRecording`** - La funci√≥n que inicia las grabaciones para incluir el hash en el nombre
4. **`mqtt-client-simple.ts`** - Para que los datos de sensores tambi√©n usen el hash

## 2. Implementaci√≥n paso a paso

### Paso 1: Modificar la creaci√≥n de sesiones

En el archivo `routes.ts` donde se procesa el endpoint POST `/api/sessions`:

```javascript
// A√±adir al inicio del archivo:
import { v4 as uuidv4 } from 'uuid';

// Modificar donde se crea la sesi√≥n (dentro del handler POST "/api/sessions"):
app.post("/api/sessions", async (req, res) => {
  if (!req.isAuthenticated()) return res.sendStatus(401);

  try {
    // Generar un hash √∫nico para esta sesi√≥n (primeros 8 caracteres de un UUID v4)
    const sessionHash = uuidv4().substring(0, 8);
    
    // Extraer resto del c√≥digo existente...
    const { title, devices, /* ... resto de campos ... */ } = req.body;
    
    // Crear el objeto de configuraci√≥n incluyendo el hash
    const config = {
      id: sessionId,
      sessionHash: sessionHash, // A√±adir el hash aqu√≠
      title,
      startTime: new Date(),
      devices,
      status: 'active',
      // ... resto de campos ...
    };
    
    // Guardar el hash en el archivo config.json para referencia futura
    fs.writeFileSync(
      path.join(sessionDir, 'config.json'),
      JSON.stringify(config, null, 2)
    );
    
    // Tambi√©n crear un archivo de √≠ndice vac√≠o que se ir√° actualizando
    const sessionIndex = {
      sessionId: sessionId,
      sessionHash: sessionHash,
      files: {
        recordings: [],
        sensorData: []
      },
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
    
    fs.writeFileSync(
      path.join(sessionDir, 'session_files_index.json'),
      JSON.stringify(sessionIndex, null, 2)
    );
    
    // Continuar con el c√≥digo existente...
    
    res.status(201).json(config);
  } catch (error) {
    // Manejo de errores...
  }
});
```

### Paso 2: Modificar la funci√≥n startRecording

En el archivo `routes.ts` donde se define la funci√≥n startRecording:

```javascript
async function startRecording(camera: any, sessionId?: number) {
  try {
    // C√≥digo existente para asegurar directorios...
    
    // Obtener el hash de la sesi√≥n si existe
    let sessionHash = '';
    if (sessionId) {
      try {
        const sessionDir = path.join(process.cwd(), 'sessions', `Session${sessionId}`);
        const configPath = path.join(sessionDir, 'config.json');
        
        if (fs.existsSync(configPath)) {
          const config = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
          sessionHash = config.sessionHash || '';
          console.log(`Usando hash de sesi√≥n: ${sessionHash} para grabaci√≥n`);
        }
      } catch (error) {
        console.error('Error al obtener hash de sesi√≥n:', error);
      }
    }

    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    
    // Incorporar el hash de la sesi√≥n en el nombre del archivo
    const prefix = camera.name 
      ? camera.name.toLowerCase().replace(/\s+/g, '-') 
      : (camera.recordingPrefix 
          ? `${camera.recordingPrefix}` 
          : `cam${camera.id}`);
    
    // Nuevo formato de nombre de archivo con hash de sesi√≥n
    const fileName = sessionHash 
      ? `${prefix}_${sessionHash}_${timestamp}.mp4` 
      : `${prefix}_${timestamp}.mp4`;
    
    const outputPath = path.join(outputDirectory, fileName);
    
    console.log(`Path completo de grabaci√≥n: ${outputPath}`);
    
    // Resto del c√≥digo de creaci√≥n de grabaci√≥n...
    const recording = await storage.createRecording({/*...*/});
    
    // Actualizar el archivo de √≠ndice si hay sesi√≥n y hash
    if (sessionId && sessionHash) {
      try {
        const sessionDir = path.join(process.cwd(), 'sessions', `Session${sessionId}`);
        const indexPath = path.join(sessionDir, 'session_files_index.json');
        
        if (fs.existsSync(indexPath)) {
          const sessionIndex = JSON.parse(fs.readFileSync(indexPath, 'utf-8'));
          
          // A√±adir esta grabaci√≥n al √≠ndice
          sessionIndex.files.recordings.push({
            id: recording.id,
            fileName: fileName,
            path: outputPath,
            cameraId: camera.id,
            timestamp: timestamp
          });
          
          sessionIndex.updatedAt = new Date().toISOString();
          
          fs.writeFileSync(indexPath, JSON.stringify(sessionIndex, null, 2));
          console.log(`√çndice de sesi√≥n actualizado con nueva grabaci√≥n: ${fileName}`);
        }
      } catch (indexError) {
        console.error('Error al actualizar √≠ndice de sesi√≥n:', indexError);
      }
    }
    
    // Continuar con el c√≥digo existente...

    return recording;
  } catch (error) {
    console.error('Error in startRecording:', error);
    throw error;
  }
}
```

### Paso 3: Modificar el servicio MQTT para datos de sensores

En el archivo `mqtt-client-simple.ts`:

```javascript
// Dentro del m√©todo registerSession:
registerSession(sessionId: number, dataPath: string, selectedSensors: string[] = []) {
  console.log(`Registrando sesi√≥n ${sessionId} para captura de datos MQTT`);
  
  // Obtener el hash de la sesi√≥n si existe
  let sessionHash = '';
  try {
    const sessionDir = path.join(process.cwd(), 'sessions', `Session${sessionId}`);
    const configPath = path.join(sessionDir, 'config.json');
    
    if (fs.existsSync(configPath)) {
      const config = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
      sessionHash = config.sessionHash || '';
      console.log(`Usando hash de sesi√≥n: ${sessionHash} para datos MQTT`);
    }
  } catch (error) {
    console.error('Error al obtener hash de sesi√≥n para MQTT:', error);
  }
  
  // Resto del c√≥digo...
  
  // Modificar nombres de archivos para incluir el hash
  const sensorDataFileName = sessionHash 
    ? `session_${sessionId}_${sessionHash}_sensors.json` 
    : `session_${sessionId}_sensors.json`;
  
  // Guardar datos con el nuevo formato de nombre
  
  // Al guardar cada evento de sensor, actualizar el √≠ndice
  if (sessionHash) {
    try {
      const sessionDir = path.join(process.cwd(), 'sessions', `Session${sessionId}`);
      const indexPath = path.join(sessionDir, 'session_files_index.json');
      
      if (fs.existsSync(indexPath)) {
        const sessionIndex = JSON.parse(fs.readFileSync(indexPath, 'utf-8'));
        
        // A√±adir este archivo de sensor al √≠ndice
        sessionIndex.files.sensorData.push({
          fileName: sensorDataFileName,
          path: path.join(sessionDir, sensorDataFileName),
          sensor: sensorId,
          timestamp: new Date().toISOString()
        });
        
        sessionIndex.updatedAt = new Date().toISOString();
        
        fs.writeFileSync(indexPath, JSON.stringify(sessionIndex, null, 2));
        console.log(`√çndice de sesi√≥n actualizado con nuevo dato de sensor: ${sensorDataFileName}`);
      }
    } catch (indexError) {
      console.error('Error al actualizar √≠ndice de sesi√≥n para sensor:', indexError);
    }
  }
}
```

### Paso 4: Modificar el servicio de archivado para usar el √≠ndice

En el archivo `archive-service.ts`:

```javascript
// Modificar el m√©todo addAdditionalSessionFiles:
private async addAdditionalSessionFiles(zip: AdmZip, sessionId: number | string, session: Session): Promise<void> {
  try {
    console.log(`Iniciando b√∫squeda para la sesi√≥n ${sessionId}`);
    const sessionDir = await sessionService.getSessionDirectory(sessionId);
    
    // USAR EL √çNDICE SI EXISTE (NUEVA IMPLEMENTACI√ìN)
    const indexPath = path.join(sessionDir, 'session_files_index.json');
    if (fs.existsSync(indexPath)) {
      console.log(`üìÅ √çndice de sesi√≥n encontrado: ${indexPath}`);
      
      try {
        const sessionIndex = JSON.parse(fs.readFileSync(indexPath, 'utf-8'));
        const sessionHash = sessionIndex.sessionHash;
        
        console.log(`üîç Usando √≠ndice con hash: ${sessionHash}`);
        
        // A√±adir grabaciones del √≠ndice
        if (sessionIndex.files.recordings && sessionIndex.files.recordings.length > 0) {
          console.log(`üìä A√±adiendo ${sessionIndex.files.recordings.length} grabaciones del √≠ndice`);
          
          for (const recording of sessionIndex.files.recordings) {
            if (fs.existsSync(recording.path)) {
              zip.addLocalFile(recording.path, 'recordings');
              console.log(`‚úÖ A√±adido archivo de video indexado: ${recording.fileName}`);
            } else {
              console.log(`‚ö†Ô∏è No se encontr√≥ el archivo indexado: ${recording.path}`);
            }
          }
        }
        
        // A√±adir datos de sensores del √≠ndice
        if (sessionIndex.files.sensorData && sessionIndex.files.sensorData.length > 0) {
          console.log(`üìä A√±adiendo ${sessionIndex.files.sensorData.length} archivos de datos del √≠ndice`);
          
          for (const sensorData of sessionIndex.files.sensorData) {
            if (fs.existsSync(sensorData.path)) {
              zip.addLocalFile(sensorData.path, 'data/sensor_data');
              console.log(`‚úÖ A√±adido archivo de datos indexado: ${sensorData.fileName}`);
            } else {
              console.log(`‚ö†Ô∏è No se encontr√≥ el archivo indexado: ${sensorData.path}`);
            }
          }
        }
        
        // A√±adir el propio archivo de √≠ndice
        zip.addLocalFile(indexPath, 'data');
        console.log(`‚úÖ A√±adido archivo de √≠ndice al ZIP`);
        
        // ¬°IMPORTANTE! Detener aqu√≠ si encontramos un √≠ndice v√°lido
        // No mezclar con el m√©todo antiguo para evitar duplicados o archivos incorrectos
        return;
      } catch (indexError) {
        console.error('Error al procesar √≠ndice de sesi√≥n:', indexError);
        // Continuar con el m√©todo antiguo si hay alg√∫n problema con el √≠ndice
      }
    }
    
    // M√âTODO ANTIGUO (FALLBACK PARA SESIONES EXISTENTES)
    console.log(`‚ö†Ô∏è No se encontr√≥ √≠ndice, usando m√©todo de b√∫squeda tradicional`);
    
    // Aqu√≠ continuar√≠a el c√≥digo original...
    // [c√≥digo de b√∫squeda existente]
  } catch (error) {
    console.error('Error al a√±adir archivos adicionales al ZIP:', error);
  }
}
```

## 3. Consideraciones adicionales

1. **Retrocompatibilidad**: Las sesiones existentes seguir√°n usando el m√©todo actual, mientras que las nuevas sesiones usar√°n el sistema de hash e √≠ndice.

2. **Depuraci√≥n**: A√±ade registros detallados mientras implementas esto para asegurarte de que funciona correctamente.

3. **Pruebas**: Antes de implementar en producci√≥n, prueba el sistema en un entorno controlado con diferentes tipos de sesiones.

Esta implementaci√≥n permitir√° que a partir de ahora, todas las nuevas sesiones tengan un identificador √∫nico y todos sus archivos compartan ese identificador, lo que evitar√° problemas de mezcla de datos entre sesiones.