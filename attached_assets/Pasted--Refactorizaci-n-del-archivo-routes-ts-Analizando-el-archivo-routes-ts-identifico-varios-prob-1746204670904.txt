# Refactorización del archivo routes.ts

Analizando el archivo `routes.ts`, identifico varios problemas que afectan su mantenibilidad y escalabilidad:

1. Es extremadamente extenso (más de 2000 líneas)
2. Mezcla múltiples responsabilidades
3. Contiene funciones muy largas y complejas
4. Tiene código duplicado
5. Gestiona estado global con variables compartidas

## Propuesta de refactorización

Recomiendo dividir el archivo en módulos siguiendo principios de diseño modular y separación de responsabilidades:

```
src/
├── config/
│   ├── paths.ts
│   └── mqtt.ts
├── services/
│   ├── camera.service.ts
│   ├── recording.service.ts
│   ├── session.service.ts
│   ├── websocket.service.ts
│   ├── mqtt.service.ts
│   └── analysis.service.ts
├── controllers/
│   ├── camera.controller.ts
│   ├── recording.controller.ts
│   ├── session.controller.ts
│   ├── analysis.controller.ts
│   └── zigbee.controller.ts
├── middleware/
│   ├── auth.middleware.ts
│   └── error.middleware.ts
├── utils/
│   ├── file.utils.ts
│   ├── process.utils.ts
│   └── logging.utils.ts
└── routes/
    ├── index.ts
    ├── camera.routes.ts
    ├── recording.routes.ts
    ├── session.routes.ts
    ├── analysis.routes.ts
    └── zigbee.routes.ts
```

## Implementación práctica

A continuación muestro la implementación de algunos componentes clave:

### 1. Archivo `config/paths.ts`

```typescript
import path from 'path';
import fs from 'fs';

// Definición de rutas para almacenamiento
const RECORDINGS_DIR = path.join(process.cwd(), "recordings");
const THUMBNAILS_DIR = path.join(process.cwd(), "public", "thumbnails");
const SESSIONS_DIR = path.join(process.cwd(), "sessions");
const DATA_DIR = path.join(process.cwd(), "data");
const TEMP_DIR = path.join(process.cwd(), 'temp');

// Crear directorios si no existen
[RECORDINGS_DIR, THUMBNAILS_DIR, SESSIONS_DIR, DATA_DIR, TEMP_DIR].forEach(dir => {
  if (!fs.existsSync(dir)) {
    try {
      fs.mkdirSync(dir, { recursive: true, mode: 0o755 });
      console.log(`Directorio creado: ${dir}`);
    } catch (error) {
      console.error(`Error al crear directorio ${dir}:`, error);
    }
  }
});

export {
  RECORDINGS_DIR,
  THUMBNAILS_DIR,
  SESSIONS_DIR,
  DATA_DIR,
  TEMP_DIR
};
```

### 2. Archivo `services/camera.service.ts`

```typescript
import fs from 'fs';
import { spawn } from 'child_process';
import { promisify } from 'util';
import { exec as execCallback } from 'child_process';
import { storage } from '../storage';
import { buildRtspUrl } from '@shared/schema';
import ping from 'ping';
import { WebSocket } from 'ws';

const exec = promisify(execCallback);

// Mapa para mantener referencias a procesos de streaming
const streamProcesses = new Map<number, { process: any, clients: Set<WebSocket> }>();

export class CameraService {
  async getAll(userId: number) {
    return await storage.getCameras(userId);
  }

  async getById(id: number) {
    return await storage.getCamera(id);
  }

  async create(camera: any, userId: number) {
    return await storage.createCamera({
      ...camera,
      userId
    });
  }

  async update(id: number, update: any, userId: number) {
    const camera = await storage.getCamera(id);
    if (!camera || camera.userId !== userId) {
      throw new Error("Camera not found or access denied");
    }
    return await storage.updateCamera(id, update);
  }

  async delete(id: number, userId: number) {
    const camera = await storage.getCamera(id);
    if (!camera || camera.userId !== userId) {
      throw new Error("Camera not found or access denied");
    }
    await storage.deleteCamera(id);
    return true;
  }

  async checkStatus(id: number) {
    const camera = await storage.getCamera(id);
    if (!camera) {
      throw new Error("Camera not found");
    }

    // Actualizar estado a "checking"
    await storage.updateCameraStatus(id, 'checking');

    try {
      // Extraer IP limpia para ping
      const ipAddress = camera.ipAddress;
      const cleanIp = ipAddress.replace(/^https?:\/\//, '').split(':')[0].split('/')[0];
      
      // Realizar ping con múltiples intentos para mayor fiabilidad
      const pingResult = await this.pingWithRetry(cleanIp, 3);
      
      // Determinar estado según resultado
      let status = pingResult.isAlive ? 'connected' : 
                   pingResult.error ? 'error' : 'disconnected';
                   
      // Actualizar estado en base de datos
      await storage.updateCameraStatus(id, status);
      
      return {
        id,
        ipAddress,
        status,
        error: pingResult.error,
        successRate: pingResult.successRate
      };
    } catch (error) {
      await storage.updateCameraStatus(id, 'error');
      throw error;
    }
  }

  // Método privado para realizar ping con reintentos
  private async pingWithRetry(ip: string, attempts = 3, timeout = 2000) {
    if (!ip || ip.trim() === '') {
      return { isAlive: false, successRate: 0, error: 'No IP address configured' };
    }
    
    let successCount = 0;
    let lastError = null;
    let results = [];
    
    for (let i = 0; i < attempts; i++) {
      try {
        const pingCommand = process.platform === 'win32'
          ? `ping -n 1 -w ${timeout} ${ip}`
          : `ping -c 1 -W ${Math.ceil(timeout/1000)} ${ip}`;
        
        const { stdout } = await exec(pingCommand);
        
        const success = stdout.includes('TTL=') || 
                     stdout.includes('ttl=') || 
                     stdout.includes('time=');
        
        if (success) {
          successCount++;
          results.push(true);
        } else {
          results.push(false);
        }
      } catch (err) {
        lastError = err.message;
        results.push(false);
      }
      
      if (i < attempts - 1) {
        await new Promise(resolve => setTimeout(resolve, 300));
      }
    }
    
    const successRate = (successCount / attempts) * 100;
    const isAlive = successCount > 0;
    
    return {
      isAlive,
      successRate,
      results,
      error: lastError
    };
  }

  async startStreaming(camera: any, ws: WebSocket) {
    try {
      let streamProcess = streamProcesses.get(camera.id);

      if (!streamProcess) {
        const rtspUrl = buildRtspUrl(camera);
        console.log(`Starting stream for camera ${camera.id} - ${rtspUrl}`);

        // Actualizar estado inicial
        await storage.updateCamera(camera.id, {
          status: 'connecting',
          lastSeen: new Date()
        });

        const ffmpeg = spawn('ffmpeg', [
          '-rtsp_transport', 'tcp',
          '-i', rtspUrl,
          '-f', 'mpegts',
          '-codec:v', 'mpeg1video',
          '-s', '640x480',
          '-b:v', '800k',
          '-r', '30',
          '-bf', '0',
          '-muxdelay', '0.001',
          'pipe:1'
        ]);

        let isConnected = false;

        streamProcess = {
          process: ffmpeg,
          clients: new Set([ws])
        };

        ffmpeg.stdout.on('data', (data) => {
          // Si recibimos datos, significa que la conexión está establecida
          if (!isConnected) {
            isConnected = true;
            storage.updateCamera(camera.id, {
              status: 'connected',
              lastSeen: new Date()
            }).catch(console.error);
          }

          streamProcess?.clients.forEach(client => {
            if (client.readyState === WebSocket.OPEN) {
              try {
                client.send(data);
              } catch (error) {
                console.error(`Error sending stream data to client:`, error);
              }
            }
          });
        });

        ffmpeg.stderr.on('data', (data) => {
          const output = data.toString();

          // Detectar errores comunes
          if (output.includes('Connection refused') || output.includes('Connection timed out')) {
            storage.updateCamera(camera.id, {
              status: 'error',
              metrics: {
                ...camera.metrics,
                connectionErrors: (camera.metrics?.connectionErrors || 0) + 1,
                lastErrorTime: new Date(),
                lastErrorMessage: output
              }
            }).catch(console.error);
          }
        });

        ffmpeg.on('error', () => {
          ws.close();
        });

        ffmpeg.on('close', () => {
          streamProcesses.delete(camera.id);
          ws.close();
        });

        streamProcesses.set(camera.id, streamProcess);
      } else {
        streamProcess.clients.add(ws);
      }

      ws.on('close', () => {
        const process = streamProcesses.get(camera.id);
        if (process) {
          process.clients.delete(ws);
          if (process.clients.size === 0) {
            process.process.kill();
            streamProcesses.delete(camera.id);
          }
        }
      });
    } catch (error) {
      ws.close();
      throw error;
    }
  }
}

export const cameraService = new CameraService();
```

### 3. Archivo `controllers/camera.controller.ts`

```typescript
import { Request, Response } from 'express';
import { cameraService } from '../services/camera.service';
import { ZodError } from "zod";
import { insertCameraSchema } from "@shared/schema";
import { websocketService } from '../services/websocket.service';

export const cameraController = {
  // Obtener todas las cámaras del usuario
  getAll: async (req: Request, res: Response) => {
    try {
      const cameras = await cameraService.getAll(req.user!.id);
      res.json(cameras);
    } catch (error) {
      console.error('Error fetching cameras:', error);
      res.status(500).json({ message: "Failed to fetch cameras" });
    }
  },

  // Crear nueva cámara
  create: async (req: Request, res: Response) => {
    try {
      const camera = insertCameraSchema.parse(req.body);
      const newCamera = await cameraService.create(camera, req.user!.id);
      
      // Notificar a todos los clientes conectados
      websocketService.broadcastMessage({ 
        type: "camera_added", 
        camera: newCamera 
      });
      
      res.status(201).json(newCamera);
    } catch (e) {
      if (e instanceof ZodError) {
        res.status(400).json(e.errors);
      } else {
        console.error('Error creating camera:', e);
        const errorMessage = e instanceof Error ? e.message : "Internal server error";
        res.status(500).json({ message: errorMessage });
      }
    }
  },

  // Actualizar cámara existente
  update: async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      const updatedCamera = await cameraService.update(
        parseInt(id), 
        req.body, 
        req.user!.id
      );
      
      // Notificar a todos los clientes conectados
      websocketService.broadcastMessage({ 
        type: "camera_updated", 
        camera: updatedCamera 
      });
      
      res.json(updatedCamera);
    } catch (error) {
      console.error('Error updating camera:', error);
      res.status(500).json({ message: "Failed to update camera" });
    }
  },

  // Eliminar cámara
  delete: async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      await cameraService.delete(parseInt(id), req.user!.id);
      
      // Notificar a todos los clientes conectados
      websocketService.broadcastMessage({ 
        type: "camera_deleted", 
        cameraId: parseInt(id)
      });
      
      res.sendStatus(204);
    } catch (error) {
      console.error('Error deleting camera:', error);
      res.status(500).json({ message: "Failed to delete camera" });
    }
  },

  // Verificar estado de cámara
  checkStatus: async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      const result = await cameraService.checkStatus(parseInt(id));
      
      // Notificar a todos los clientes conectados
      websocketService.broadcastMessage({ 
        type: "camera_status_updated", 
        camera: result
      });
      
      res.json(result);
    } catch (error) {
      console.error('Error checking camera status:', error);
      res.status(500).json({ message: "Failed to check camera status" });
    }
  }
};
```

### 4. Archivo `routes/camera.routes.ts`

```typescript
import { Router } from 'express';
import { cameraController } from '../controllers/camera.controller';
import { authMiddleware } from '../middleware/auth.middleware';

const router = Router();

// Aplicar middleware de autenticación a todas las rutas
router.use(authMiddleware);

// Rutas de cámaras
router.get('/', cameraController.getAll);
router.post('/', cameraController.create);
router.get('/:id', cameraController.getById);
router.patch('/:id', cameraController.update);
router.delete('/:id', cameraController.delete);
router.get('/:id/ping', cameraController.checkStatus);
router.post('/:id/record', cameraController.startRecording);
router.post('/:id/stop-recording', cameraController.stopRecording);
router.get('/:id/recordings', cameraController.getRecordings);

export default router;
```

### 5. Archivo `routes/index.ts`

```typescript
import { Express } from 'express';
import { Server } from 'http';
import { setupAuth } from '../auth';
import { setupWebSocketServer } from '../services/websocket.service';
import cameraRoutes from './camera.routes';
import recordingRoutes from './recording.routes';
import sessionRoutes from './session.routes';
import analysisRoutes from './analysis.routes';
import zigbeeRoutes from './zigbee.routes';
import { errorMiddleware } from '../middleware/error.middleware';

export async function registerRoutes(app: Express): Promise<Server> {
  const server = setupAuth(app);
  
  // Configurar WebSocket server
  setupWebSocketServer(server);
  
  // Registrar todas las rutas
  app.use('/api/cameras', cameraRoutes);
  app.use('/api/recordings', recordingRoutes);
  app.use('/api/sessions', sessionRoutes);
  app.use('/api/analysis', analysisRoutes);
  app.use('/api/zigbee', zigbeeRoutes);
  
  // Middleware para manejo de errores (debe ser el último)
  app.use(errorMiddleware);
  
  return server;
}
```

### 6. Archivo `services/websocket.service.ts`

```typescript
import { WebSocketServer, WebSocket } from 'ws';
import { Server } from 'http';

let wss: WebSocketServer;

export function setupWebSocketServer(server: Server) {
  wss = new WebSocketServer({ 
    server, 
    path: "/ws",
    verifyClient: (info: any, done: any) => {
      // Log connection attempts without requiring authentication
      console.log(`WebSocket connection attempt from ${info.req.socket.remoteAddress}`);
      done(true);
    }
  });

  wss.on('connection', (ws, req) => {
    const url = new URL(req.url ?? '', 'http://localhost');
    const cameraId = url.pathname.split('/')[2]; // /stream/:cameraId

    // Handle camera streaming connections
    if (cameraId) {
      handleCameraStream(ws, cameraId);
    }
  });

  return wss;
}

// Handle camera streaming via WebSocket
async function handleCameraStream(ws: WebSocket, cameraId: string) {
  try {
    // Import services dynamically to avoid circular dependencies
    const { cameraService } = await import('./camera.service');
    const { storage } = await import('../storage');
    
    const camera = await storage.getCamera(parseInt(cameraId));
    if (!camera) {
      console.log(`Camera ${cameraId} not found, closing connection`);
      ws.close();
      return;
    }

    await cameraService.startStreaming(camera, ws);
  } catch (error) {
    console.error(`Error handling WebSocket camera stream: ${error}`);
    ws.close();
  }
}

export const websocketService = {
  // Broadcast message to all connected clients
  broadcastMessage: (message: any) => {
    if (!wss) {
      console.warn('WebSocket server not initialized');
      return;
    }
    
    wss.clients.forEach((client) => {
      if (client.readyState === WebSocket.OPEN) {
        client.send(JSON.stringify(message));
      }
    });
  },
  
  // Send message to specific client
  sendMessageToClient: (client: WebSocket, message: any) => {
    if (client.readyState === WebSocket.OPEN) {
      client.send(JSON.stringify(message));
    }
  },
  
  // Get WebSocket server instance
  getServer: () => wss
};
```

## Beneficios de esta refactorización

1. **Mantenibilidad mejorada**: Cada módulo tiene una única responsabilidad
2. **Mayor testabilidad**: Es más fácil probar componentes aislados
3. **Mejor organización**: La estructura es clara y sigue principios SOLID
4. **Reutilización de código**: Las funcionalidades comunes están en servicios compartidos
5. **Mejor manejo de errores**: Enfoque consistente en todo el código
6. **Código más limpio**: Funciones más pequeñas y enfocadas

Esta estructura facilita el desarrollo futuro, permite una mejor colaboración en equipo y hace que el sistema sea más fácil de entender y mantener a largo plazo.