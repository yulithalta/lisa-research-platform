# Informe de Análisis de Código: Detectar Duplicidad y Código Muerto

## Resumen Ejecutivo

He analizado el código proporcionado y he identificado varios casos de código duplicado, funcionalidades redundantes y código muerto que podrían beneficiarse de una refactorización. Este informe detalla estos hallazgos para que los desarrolladores puedan mejorar la estructura y mantenibilidad del código.

## 1. Duplicidad en Funciones de Grabación

### Funciones Redundantes para Grabación

Las siguientes funciones realizan tareas similares relacionadas con la grabación:

```javascript
// Función 1: startRecording
async function startRecording(camera: any, sessionId?: number) {
  // Inicialización de grabación...
}

// Función 2: Dentro de POST "/api/sessions"
// Tiene lógica duplicada para iniciar grabaciones
app.post("/api/sessions", async (req, res) => {
  // ...
  // Iniciar grabación para las cámaras seleccionadas
  if (sessionData.cameras && sessionData.cameras.length > 0) {
    for (const cameraId of sessionData.cameras) {
      // Lógica duplicada para iniciar grabación
      const camera = await storage.getCamera(cameraId);
      // Más lógica...
      const recording = await startRecording(cameraWithSessionInfo);
    }
  }
  // ...
});

// Función 3: En POST "/api/cameras/:id/record"
app.post("/api/cameras/:id/record", async (req, res) => {
  // ...
  // Inicia grabación con lógica duplicada
  try {
    // Crear un registro de grabación en la base de datos
    const recording = await storage.createRecording({
      cameraId: camera.id,
      userId: req.user.id,
      status: 'recording',
      // ...
    });
    
    // Iniciar el proceso de grabación
    await startRecording(camera);
    // ...
  } catch (recordError) {
    // ...
  }
});
```

**Recomendación**: Consolidar toda la lógica de inicio de grabación en una única función que tome parámetros estandarizados.

## 2. Duplicidad en Funciones de Búsqueda de Archivos

He encontrado lógica duplicada para la búsqueda de archivos de grabación:

```javascript
// Duplicado 1: En "/api/recordings/:id/download"
app.get("/api/recordings/:id/download", async (req, res) => {
  // ...
  if (!fs.existsSync(filePath)) {
    // Búsqueda de archivos alternativos con lógica duplicada
    let alternativePath = null;
    const dirsToCheck = [
      path.join(process.cwd(), 'sessions', `Session${recording.sessionId}`, 'recordings'),
      // Más directorios...
    ];
    // Lógica de búsqueda en directorios
  }
  // ...
});

// Duplicado 2: En "/api/recordings/:id/stream"
app.get("/api/recordings/:id/stream", async (req, res) => {
  // ...
  if (!fs.existsSync(recording.filePath)) {
    // Búsqueda de archivos alternativos con lógica casi idéntica
    let alternativePath = null;
    const dirsToCheck = [
      path.join(process.cwd(), 'sessions', `Session${recording.sessionId}`, 'recordings'),
      // Mismos directorios...
    ];
    // Búsqueda en directorios duplicada
  }
  // ...
});
```

**Recomendación**: Crear una función de utilidad `findRecordingFilePath(recording)` que encapsule esta lógica.

## 3. Múltiples Implementaciones MQTT

Existe código duplicado relacionado con clientes MQTT:

```javascript
// Referencia 1: Importación directa
const mqttClient = require('./mqtt-client').default.getInstance();

// Referencia 2: Manipulación duplicada con manejo condicional
try {
  // Intentar usar primero el cliente MQTT simplificado
  try {
    const { mqttClient } = require('./mqtt-client-simple');
    
    if (mqttClient && typeof mqttClient.endSession === 'function') {
      mqttClient.endSession(parseInt(sessionId));
      // ...
    } else {
      // Fallback al cliente original
      try {
        const { mqttClient: originalMqttClient } = require('./mqtt-client');
        // ...
      } catch (originalError) {
        // ...
      }
    }
  } catch (simpleMqttError) {
    // Fallback nuevamente al cliente original...
  }
} catch (mqttError) {
  // ...
}

// Referencia 3: Importación con comprobación diferente
let mqttClient;
try {
  mqttClient = require('./mqtt-client-simple').mqttClient;
  // ...
} catch (simpleMqttError) {
  // Fallback al cliente original
  mqttClient = require('./mqtt-client').mqttClient;
  // ...
}
```

**Recomendación**: Implementar un singleton `MQTTClientFactory` que gestione todas las operaciones MQTT y unifique la lógica.

## 4. Funciones Redundantes de Exportación

Las funciones de exportación contienen lógica duplicada:

```javascript
// Duplicado 1: handleExportSensorData
const handleExportSensorData = async (sessionId: number, format: 'json' | 'csv') => {
  try {
    const res = await apiRequest("GET", `/api/sessions/${sessionId}/export/sensors?format=${format}`);
    const blob = await res.blob();
    
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `session-${sessionId}-sensors.${format}`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    
    toast({
      // ...
    });
  } catch (error) {
    // ...
  }
};

// Duplicado 2: handleExportAllData
const handleExportAllData = async (sessionId: number) => {
  try {
    const res = await apiRequest("GET", `/api/sessions/${sessionId}/export/all`);
    const blob = await res.blob();
    
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `session-${sessionId}-all.zip`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    
    toast({
      // ...
    });
  } catch (error) {
    // ...
  }
};
```

**Recomendación**: Crear una función de utilidad `downloadFile(url, filename)` que encapsule la lógica de descarga.

## 5. Duplicidad en Endpoints de Exportación

Existen múltiples endpoints para gestionar la exportación de datos:

```javascript
// Endpoint 1: Exportación de datos de sensores
app.get("/api/sessions/:sessionId/export-sensor-data", jsonRoutes.exportSessionSensorData);

// Endpoint 2: Exportación de todos los datos
app.get("/api/sessions/:sessionId/export-all", jsonRoutes.exportAllSessionData);

// Endpoint 3: Exportación de grabación
app.get("/api/recordings/:id/export", async (req, res) => {
  // Lógica similar a los endpoints anteriores
});

// Endpoint 4: Descarga de datos de sensores
app.get("/api/recordings/:id/sensors", async (req, res) => {
  // Lógica similar
});
```

**Recomendación**: Unificar la lógica de exportación bajo un controlador común y parametrizado.

## 6. Funciones Redundantes para Verificar Cámaras

Existen múltiples implementaciones para verificar el estado de las cámaras:

```javascript
// Versión 1: verifyCameraStatus
const verifyCameraStatus = async (cameraId: number) => {
  setVerifyingCamera(cameraId);
  try {
    const response = await fetch(`/api/cameras/${cameraId}/ping`);
    const result = await response.json();
    // Lógica para actualizar estado...
  } catch (error) {
    // Manejo de error...
  }
};

// Versión 2: checkCamera (en scan.js)
function checkCamera(ip) {
  return new Promise((resolve) => {
    const rtspUrl = `rtsp://${VIEWER_USER}:${VIEWER_PASS}@${ip}:554/h264Preview_01_sub`;
    // Más lógica de verificación...
  });
}

// Versión 3: En el endpoint "/api/cameras/:id/ping"
app.get("/api/cameras/:id/ping", async (req, res) => {
  try {
    // Función mejorada para verificar cámaras con ping
    const checkCamera = async (ip: string, attempts = 3, timeout = 2000) => {
      // Lógica similar pero diferente...
    };
    
    // Verificar la cámara con ping
    const pingResult = await checkCamera(ipAddress);
    // Más lógica...
  } catch (error) {
    // ...
  }
});

// Versión 4: En "/api/cameras/check-all"
app.post("/api/cameras/check-all", async (req, res) => {
  // ...
  const checkCamera = async (ip: string, attempts = 5, timeout = 1500) => {
    // Lógica similar pero diferente de nuevo...
  };
  // ...
});
```

**Recomendación**: Crear un servicio `CameraHealthService` que encapsule toda la lógica de verificación.

## 7. Código Potencialmente Muerto

He identificado secciones de código que podrían no estar en uso:

```javascript
// Función analyzeVideo: Nunca se llama directamente,
// solo como parte de un proceso de análisis que parece incompleto
async function analyzeVideo(filePath: string, analysisId: string): Promise<any> {
  console.log(`Iniciando análisis real de video para ${filePath} con ID ${analysisId}`);
  
  // Análisis simulado, no real
  try {
    // Inicializar el estado de progreso
    analysisProgress.set(analysisId, { 
      progress: 0, 
      status: 'processing', 
      framesAnalyzed: 0, 
      totalFrames: 0, 
      errorMessage: null 
    });
    
    // Este análisis es "falso" - solo simula un progreso
    // pero no realiza ningún análisis real
    // ...

    return {
      description: "Nota: Esta es una representación de los resultados que se obtendrían del análisis real de video.",
      tags: ["análisis pendiente"],
      keyEvents: [
        "Análisis real pendiente de implementación con herramientas específicas"
      ],
      timestamp: new Date()
    };
  } catch (error) {
    // ...
  }
}
```

**Recomendación**: Completar esta implementación o eliminarla si no está en uso.

## 8. Duplicidad en Manejo de Archivos JSON/CSV

Existen múltiples implementaciones para procesar archivos JSON y CSV:

```javascript
// Versión 1: Consolidación de datos sensoriales en ZIP
try {
  const sensorFiles = fs.readdirSync(sensorDataPath).filter(file => file.endsWith('.json'));
  const allSensorData = {};
  
  // Procesamiento...
  
  fs.writeFileSync(tempConsolidatedPath, JSON.stringify(finalDataToSave, null, 2));
  // ...
} catch (consolidationErr) {
  // ...
}

// Versión 2: En otro endpoint
// Búsqueda y procesamiento de CSV de forma diferente
const sensorDataCsvPath = path.join(sensorDataPath, `session_${sessionId}_data.csv`);
if (fs.existsSync(sensorDataCsvPath)) {
  archive.file(sensorDataCsvPath, { name: 'sensor_data/sensors.csv' });
  // ...
} else {
  // Buscar en otro directorio...
}
```

**Recomendación**: Unificar el procesamiento de archivos JSON/CSV en servicios especializados.

## 9. Múltiples Sistemas de Notificación

Diferentes partes del código utilizan distintos métodos para notificar cambios:

```javascript
// Método 1: WebSocket
wss.clients.forEach((client: any) => {
  if (client.readyState === WebSocket.OPEN) {
    client.send(JSON.stringify({
      type: "camera_status_updated",
      camera: { id: parseInt(id), status, ipAddress } 
    }));
  }
});

// Método 2: Toast notifications en frontend
toast({
  title: "Session created",
  description: "The session has been created successfully. Recordings started.",
});

// Método 3: Logging
console.log(`Cámara ${id} marcada como conectada con tasa de éxito ${pingResult.successRate.toFixed(1)}%`);
```

**Recomendación**: Implementar un sistema unificado de eventos/notificaciones.

## 10. Código Repetitivo para Manejo de Sesiones

Existe código duplicado en el manejo de sesiones:

```javascript
// Duplicado 1: Verificación de existencia de sesión activa
if (activeSession) {
  toast({
    title: "Error",
    description: "There is already an active session. Please end it before starting a new one.",
    variant: "destructive",
  });
  return;
}

// Duplicado 2: Verificación similar en otro componente
const activeSession = sessions.find(s => s.status === 'active');
// Uso similar...

// Duplicado 3: En endpoint de creación
if (session.status === 'active' && req.body.status === 'completed') {
  console.log(`Completing active session ${sessionId}`);
  // Lógica para completar sesión activa...
}
```

**Recomendación**: Implementar un gestor de sesiones unificado (SessionManager) que encapsule esta lógica.

## Conclusiones y Recomendaciones Generales

1. **Arquitectura**: Adoptar una arquitectura más modular, separando claramente el código por responsabilidades.

2. **Servicios**: Implementar servicios especializados para:
   - Gestión de grabaciones (RecordingService)
   - Gestión de sesiones (SessionService)
   - Comunicación MQTT (MQTTService)
   - Verificación de cámaras (CameraHealthService)
   - Exportación de datos (ExportService)

3. **Utilidades**:
   - Centralizar funciones comunes de manipulación de archivos
   - Unificar la lógica de búsqueda de rutas
   - Crear helpers para operaciones repetitivas

4. **Constantes y Configuración**:
   - Centralizar rutas y patrones de nombres de archivo
   - Unificar la configuración de directorios

5. **Gestión de Errores**:
   - Normalizar el manejo de errores en todas las funciones
   - Implementar un sistema de logging unificado

Es un punto crítico que definitivamente debemos incluir en el informe. Las rutas absolutas son un problema serio en aplicaciones que serán dockerizadas y desplegadas en diferentes entornos. Añadiré esta sección al informe:

## 11. Rutas Absolutas y Problemas de Portabilidad para Dockerización

He identificado numerosas rutas absolutas que causarán problemas graves cuando la aplicación se despliegue en producción, especialmente en un entorno dockerizado:

```javascript
// Ejemplo 1: Rutas absolutas en creación de directorios
const RECORDINGS_DIR = path.join(process.cwd(), "recordings");
const THUMBNAILS_DIR = path.join(process.cwd(), "recordings", "thumbnails");
const SESSIONS_DIR = path.join(process.cwd(), "sessions");

// Ejemplo 2: Ruta absoluta codificada para buscar archivos
const sessionDir = path.join(process.cwd(), 'sessions', `Session${sessionId}`);

// Ejemplo 3: Referencias a rutas específicas de desarrollo
const alternativePaths = [
  path.join(process.cwd(), 'sessions', `Session${recording.sessionId}`, 'recordings'),
  path.join('/home/mforum/Documentos/aplicaciones/tfg/paneldecontrol/Lisa3.1.6-SensorSessionTracker', 'recordings'),
  path.join('/home/mforum/Documentos/aplicaciones/tfg/paneldecontrol/Lisa3.1.6-SensorSessionTracker/data', 'recordings'),
  path.join('/home/mforum/Documentos/aplicaciones/tfg/paneldecontrol/EnterpriseWorkflow/recordings'),
  '/home/orangepi/Documentos/WebUbicuos/EnterpriseWorkflow/recordings'
];

// Ejemplo 4: Rutas con referencias a estructuras de directorios locales
const principalSessionDir = path.join(process.cwd(), 'sessions', `Session${sessionIdStr}`);
```

**Problemas críticos**:

1. **Incompatibilidad con Docker**: En entornos dockerizados, la estructura de directorios será diferente y las rutas absolutas causarán fallos.

2. **Dependencia de rutas de desarrollo**: Existen referencias a rutas específicas de desarrollo que no existirán en producción.

3. **Falta de configuración por entorno**: No existe un sistema para adaptar rutas según el entorno (desarrollo/producción).

4. **Inconsistencia en la gestión de rutas**: Se utilizan diferentes enfoques para construir rutas en diferentes partes del código.

**Recomendaciones urgentes**:

1. **Utilizar variables de entorno**:
   ```javascript
   // Configuración por variables de entorno
   const DATA_BASE_DIR = process.env.DATA_BASE_DIR || path.join(process.cwd(), 'data');
   const RECORDINGS_DIR = path.join(DATA_BASE_DIR, "recordings");
   ```

2. **Implementar gestión de configuración por entorno**:
   ```javascript
   // config.js
   const configs = {
     development: {
       dataDir: path.join(process.cwd(), 'data'),
       recordingsDir: path.join(process.cwd(), 'recordings')
     },
     production: {
       dataDir: '/app/data',
       recordingsDir: '/app/recordings'
     }
   };
   
   const env = process.env.NODE_ENV || 'development';
   module.exports = configs[env];
   ```

3. **Centralizar la lógica de resolución de rutas**:
   ```javascript
   // paths.js
   const config = require('./config');
   
   module.exports = {
     getRecordingsPath: () => config.recordingsDir,
     getSessionPath: (sessionId) => path.join(config.dataDir, 'sessions', `Session${sessionId}`),
     getSessionRecordingsPath: (sessionId) => path.join(config.dataDir, 'sessions', `Session${sessionId}`, 'recordings')
   };
   ```

4. **Crear volúmenes Docker dedicados**: Definir volúmenes específicos en `docker-compose.yml` para datos persistentes:
   ```yaml
   volumes:
     recordings:
       driver: local
     sessions:
       driver: local
   
   services:
     app:
       # ...
       volumes:
         - recordings:/app/recordings
         - sessions:/app/sessions
         - ./config:/app/config
       environment:
         - NODE_ENV=production
         - DATA_BASE_DIR=/app/data
   ```

5. **Eliminar todas las rutas codificadas**: Buscar y eliminar todas las rutas absolutas y específicas del entorno de desarrollo.

Esta refactorización es **crítica** para garantizar que la aplicación funcione correctamente cuando se despliegue en producción en un entorno dockerizado.

## Conclusiones y Recomendaciones Generales

[Contenido previo de conclusiones...]

6. **Gestión de rutas y configuración**:
   - Implementar un sistema de configuración basado en entorno
   - Eliminar todas las rutas absolutas y referencias a entornos específicos
   - Centralizar la lógica de resolución de rutas en un servicio dedicado
   - Preparar adecuadamente el proyecto para su dockerización


Este informe identifica las áreas principales donde se puede mejorar el código. Recomiendo abordar primero los problemas relacionados con la duplicidad en las funciones de grabación y búsqueda de archivos, ya que estos parecen ser los más relevantes para el problema actual de almacenamiento de videos. Además se identifica las áreas principales donde se puede mejorar el código, incluyendo el problema crítico de las rutas absolutas para el despliegue en Docker.
