import { useQuery, useQueryClient } from "@tanstack/react-query";
import { Recording, Camera } from "@shared/schema";
import { Card, CardContent, CardHeader, CardTitle, CardDescription, CardFooter } from "@/components/ui/card";
import { Loader2, Play, Download, Search, Check, X, ChevronUp, ChevronDown, ChevronLeft, ChevronRight, Trash2, History, PlusCircle, FileVideo, StopCircle, Save, FolderClosed, AlertCircle, FileJson } from "lucide-react";
import { format, formatDuration, intervalToDuration } from "date-fns";
import { es } from "date-fns/locale";
import { Button } from "@/components/ui/button";
import { useToast } from "@/hooks/use-toast";
import { apiRequest } from "@/lib/queryClient";
import { useState, useEffect } from "react";
import { Input } from "@/components/ui/input";
import { Checkbox } from "@/components/ui/checkbox";
// import useMqtt from "@/hooks/use-mqtt";
import useSimpleMqtt from "@/hooks/use-simple-mqtt";
import { Alert, AlertTitle, AlertDescription } from "@/components/ui/alert";
import { Badge } from "@/components/ui/badge";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogFooter
} from "@/components/ui/dialog";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Progress } from "@/components/ui/progress";
import cn from 'classnames';
import {
  Tabs,
  TabsContent,
  TabsList,
  TabsTrigger,
} from "@/components/ui/tabs";

export default function SessionsPage() {
  const { data: cameras } = useQuery<Camera[]>({
    queryKey: ["/api/cameras"],
  });

  // const { sensors } = useMqtt();
  const mqttClient = useSimpleMqtt();
  const { sensors, isConnected, connectionError, sensorCount, getAllData } = mqttClient;
  const { toast } = useToast();
  const queryClient = useQueryClient();

  // Estados para el formulario y búsqueda
  const [searchQuery, setSearchQuery] = useState("");
  const [sessionSearchQuery, setSessionSearchQuery] = useState("");
  const [selectedCameras, setSelectedCameras] = useState<number[]>([]);
  const [selectedSensors, setSelectedSensors] = useState<string[]>([]);
  const [sessionTitle, setSessionTitle] = useState("");
  const [isStarting, setIsStarting] = useState(false);
  const [viewSessionData, setViewSessionData] = useState<any>(null);

  // Estado para el contador de tiempo
  const [elapsedTime, setElapsedTime] = useState<{ [key: string]: number }>({});
  const [sessionStatus, setSessionStatus] = useState<{ [key: string]: string }>({});
  const [websocket, setWebsocket] = useState<WebSocket | null>(null);

  const { data: sessions, isLoading: isLoadingSessions } = useQuery({
    queryKey: ["/api/sessions"],
    refetchInterval: 5000, // Actualizar cada 5 segundos
  });

  // Obtener la sesión activa actual (si existe)
  const activeSession = sessions?.find((session: any) => session.status === 'active');
  
  // Obtener las sesiones completadas
  const completedSessions = sessions?.filter((session: any) => session.status === 'completed') || [];

  // Filtrar sesiones basadas en la búsqueda
  const filteredSessions = sessions?.filter((session: any) => {
    if (!sessionSearchQuery) return true;
    return (
      session.title.toLowerCase().includes(sessionSearchQuery.toLowerCase()) ||
      session.id.toString().includes(sessionSearchQuery)
    );
  });

  // Conectar al WebSocket para actualizaciones en tiempo real
  useEffect(() => {
    const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
    const hostIp = import.meta.env.VITE_HOST_IP || "192.168.0.20";
    const wsUrl = `${protocol}//${window.location.host}/ws`;
    
    console.log(`Connecting to WebSocket at ${wsUrl}`);
    const ws = new WebSocket(wsUrl);
    
    ws.onopen = () => {
      console.log('Connected to WebSocket server');
      setWebsocket(ws);
    };
    
    ws.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        console.log('Received WebSocket message:', data);
        
        if (data.type === "session_deleted") {
          // Invalidar la caché cuando se elimina una sesión
          queryClient.invalidateQueries({ queryKey: ["/api/sessions"] });
          queryClient.invalidateQueries({ queryKey: ["/api/cameras"] });
          
          toast({
            title: "Sesión eliminada",
            description: "La sesión ha sido eliminada por el servidor",
          });
        } else if (data.type === "camera_updated") {
          // Actualizar estado de cámara
          queryClient.invalidateQueries({ queryKey: ["/api/cameras"] });
        } else if (data.type === "session_updated") {
          // Actualizar sesiones
          queryClient.invalidateQueries({ queryKey: ["/api/sessions"] });
        }
      } catch (error) {
        console.error('Error processing WebSocket message:', error);
      }
    };
    
    ws.onerror = (error) => {
      console.error('WebSocket error:', error);
    };
    
    ws.onclose = () => {
      console.log('WebSocket connection closed');
      setWebsocket(null);
    };
    
    return () => {
      if (ws.readyState === WebSocket.OPEN) {
        ws.close();
      }
    };
  }, []);

  // Actualizar contador de tiempo para sesiones activas
  useEffect(() => {
    const interval = setInterval(() => {
      if (sessions) {
        const newElapsedTime = { ...elapsedTime };
        const newStatus = { ...sessionStatus };

        sessions.forEach((session: any) => {
          const start = new Date(session.startTime).getTime();
          if (session.status === 'active') {
            newElapsedTime[session.id] = Math.floor((Date.now() - start) / 1000);
            newStatus[session.id] = 'active';
          } else if (session.status === 'completed') {
            const end = new Date(session.endTime).getTime();
            newElapsedTime[session.id] = Math.floor((end - start) / 1000);
            newStatus[session.id] = 'completed';
          }
        });

        setElapsedTime(newElapsedTime);
        setSessionStatus(newStatus);
      }
    }, 1000);

    return () => clearInterval(interval);
  }, [sessions]);

  // Formatear duración
  const formatTime = (seconds: number) => {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;
    return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
  };

  // Filtrar dispositivos basados en la búsqueda
  const filteredCameras = cameras?.filter(camera => {
    if (!searchQuery) return true;
    return camera.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
           camera.ipAddress.includes(searchQuery);
  }) || [];

  // Validar que los sensores tienen IEEE address y están bien formateados
  const validSensors = (sensors || []).filter((sensor: any) => 
    sensor && typeof sensor === 'object' && sensor.ieee_addr && typeof sensor.ieee_addr === 'string'
  );
  
  // Filtrar sensores según la búsqueda
  const filteredSensors = validSensors.filter((sensor: any) => {
    if (!searchQuery) return true;
    return (sensor.friendly_name || '').toLowerCase().includes(searchQuery.toLowerCase()) ||
           (sensor.ieee_addr || '').includes(searchQuery);
  });

  // Estado para tracking de cámaras siendo verificadas
  const [verifyingCameras, setVerifyingCameras] = useState<number[]>([]);
  
  // Estado para la paginación de la tabla de sensores
  const [currentPage, setCurrentPage] = useState<number>(1);
  const sensorsPerPage = 5;

  // Verificar cámara mediante ping
  const checkCameraStatus = async (cameraId: number) => {
    try {
      // Agregar cámara a la lista de verificación
      setVerifyingCameras(prev => [...prev, cameraId]);
      
      const response = await apiRequest("GET", `/api/cameras/${cameraId}/ping`);
      const result = await response.json();
      
      console.log(`Verificación de cámara ${cameraId}: ${result.status}`);
      
      // Actualizar la cache de TanStack Query para reflejar el nuevo estado
      queryClient.setQueryData(
        ["/api/cameras"],
        (oldData: Camera[] | undefined) => {
          if (!oldData) return undefined;
          
          return oldData.map(camera => 
            camera.id === cameraId 
              ? { ...camera, status: result.status } 
              : camera
          );
        }
      );
      
      // Quitar cámara de la lista de verificación
      setVerifyingCameras(prev => prev.filter(id => id !== cameraId));
      return result.status;
    } catch (error) {
      console.error(`Error verificando cámara ${cameraId}:`, error);
      // Quitar cámara de la lista de verificación en caso de error
      setVerifyingCameras(prev => prev.filter(id => id !== cameraId));
      return 'disconnected';
    }
  };

  // Manejar selección de dispositivos
  const toggleCamera = async (cameraId: number, status: string) => {
    // Verificar si la cámara está desconectada solo cuando se intenta seleccionar
    const isSelected = selectedCameras.includes(cameraId);
    
    // Si no está seleccionada, verificar su estado en tiempo real con ping
    if (!isSelected) {
      // Verificar si ya estamos comprobando esta cámara
      if (verifyingCameras.includes(cameraId)) {
        toast({
          title: "En proceso",
          description: "Ya se está verificando esta cámara, por favor espere...",
        });
        return;
      }
      
      toast({
        title: "Verificando cámara",
        description: "Comprobando disponibilidad mediante ping...",
        duration: 2000,
      });
      
      // Verificar mediante ping el estado actual de la cámara
      const currentStatus = await checkCameraStatus(cameraId);
      
      // Si la cámara está desconectada y se intenta seleccionar
      if (currentStatus !== 'connected') {
        toast({
          title: "Error",
          description: "No se puede seleccionar esta cámara porque no responde a ping",
          variant: "destructive",
          duration: 3000,
        });
        return;
      }
      
      toast({
        title: "Cámara disponible",
        description: "La cámara ha sido verificada y está disponible",
        duration: 2000,
      });
    }
    
    // Cambiar el estado de selección
    setSelectedCameras(prev =>
      isSelected
        ? prev.filter(id => id !== cameraId)
        : [...prev, cameraId]
    );
    
    console.log(`Camera ${cameraId} ${isSelected ? 'unselected' : 'selected'}, status: ${status}`);
  };

  const handleSensorChange = (sensorId: string, checked: boolean) => {
    // Log para depuración
    console.log(`Cambiando sensor ${sensorId} a ${checked ? 'seleccionado' : 'deseleccionado'}`);
    console.log('Estado previo de sensores:', selectedSensors);
    
    // Verificar que sensorId es una cadena válida
    if (!sensorId || typeof sensorId !== 'string' || sensorId.trim() === '') {
      console.error('ID de sensor inválido:', sensorId);
      return;
    }
    
    // Asegurar que el ID del sensor es único y no se confunda con otros
    const normalizedSensorId = sensorId.trim();
    
    // Implementación con copia inmutable para evitar problemas de referencia
    setSelectedSensors(prevSelected => {
      if (checked) {
        // Evitar duplicados
        if (prevSelected.includes(normalizedSensorId)) {
          return prevSelected; // No hacer cambios si ya está seleccionado
        }
        // Añadir el sensor a la selección
        console.log(`-> Sensor ${normalizedSensorId} añadido a la selección`);
        return [...prevSelected, normalizedSensorId];
      } else {
        // Eliminar el sensor si está seleccionado
        if (!prevSelected.includes(normalizedSensorId)) {
          return prevSelected; // No hacer cambios si no estaba seleccionado
        }
        console.log(`-> Sensor ${normalizedSensorId} eliminado de la selección`);
        return prevSelected.filter(id => id !== normalizedSensorId);
      }
    });
  };
  
  // Efecto para registrar cambios en la selección de sensores
  useEffect(() => {
    console.log('Sensores seleccionados actualizados:', selectedSensors);
  }, [selectedSensors]);
  
  // Efecto para resetear la paginación cuando cambie el filtro de búsqueda
  useEffect(() => {
    setCurrentPage(1);
  }, [searchQuery]);

  // Iniciar nueva sesión
  const startSession = async () => {
    if (!selectedCameras.length && !selectedSensors.length) {
      toast({
        title: "Error",
        description: "Selecciona al menos un dispositivo para iniciar la sesión",
        variant: "destructive",
      });
      return;
    }

    setIsStarting(true);
    try {
      // Primero, obtener todos los datos MQTT actuales para incluirlos 
      // en el payload de la sesión - esto asegura que se guarden correctamente
      const sensorData = getAllData();
      console.log("Datos MQTT para incluir en sesión:", {
        selectedSensors,
        sensorCount: sensorData.sensors.length,
        dataSizeEstimate: JSON.stringify(sensorData).length
      });
      
      // Crear la sesión con los datos actuales de sensores
      // Verificar si hay cámaras disponibles en el array
      if (cameras && Array.isArray(cameras)) {
        console.log("Cámaras disponibles:", cameras);
      } else {
        console.log("No hay cámaras disponibles o no es un array:", cameras);
      }

      // Crear la sesión con los datos actuales
      const response = await apiRequest("POST", "/api/sessions", {
        title: sessionTitle || `Sesión ${format(new Date(), 'dd/MM/yyyy HH:mm')}`,
        devices: {
          cameras: selectedCameras.map(id => {
            // Encontrar la cámara en el array
            const camera = cameras && Array.isArray(cameras) ? cameras.find(c => Number(c.id) === Number(id)) : null;
            console.log(`Buscando cámara con ID ${id}:`, camera);
            return {
              id,
              prefix: camera ? camera.recordingPrefix || `cam${id}` : `cam${id}`
            };
          }),
          sensors: selectedSensors
        },
        sensorData: {
          // Incluir solo los datos de sensores seleccionados en la sesión
          sensors: Array.isArray(sensorData.sensors) ? sensorData.sensors.filter(s => 
            s && s.ieee_addr && (
              selectedSensors.includes(s.ieee_addr) || 
              // Incluir siempre el sensor específico si está seleccionado
              (s.ieee_addr === '0x00124b002a6b62b7' && selectedSensors.includes('0x00124b002a6b62b7'))
            )
          ) : [],
          // Filtrar solo los topics relevantes seleccionados
          messagesByTopic: sensorData.sensorData ? Object.fromEntries(
            Object.entries(sensorData.sensorData).filter(([topic]) => 
              selectedSensors.includes(topic) || 
              selectedSensors.some(id => topic.includes(id)) ||
              // Incluir topics que mencionan al sensor específico si está seleccionado
              (selectedSensors.includes('0x00124b002a6b62b7') && 
               (topic === '0x00124b002a6b62b7' || topic.includes('0x00124b002a6b62b7')))
            )
          ) : {},
          // Incluir datos específicos del sensor si existe y está seleccionado
          specificSensorData: selectedSensors.includes('0x00124b002a6b62b7') && sensorData.specificSensorData 
            ? sensorData.specificSensorData 
            : undefined,
          timestamp: new Date().toISOString()
        }
      });

      // Notificar a la interfaz que la sesión ha sido iniciada
      websocket?.send(JSON.stringify({
        type: "session_started",
        sessionId: response.id
      }));

      // Actualizar lista de grabaciones y sesiones
      await Promise.all([
        queryClient.invalidateQueries({ queryKey: ["/api/recordings"] }),
        queryClient.invalidateQueries({ queryKey: ["/api/sessions"] })
      ]);

      toast({
        title: "Sesión iniciada",
        description: "La grabación y captura de datos ha comenzado",
      });

      // Limpiar formulario
      setSelectedCameras([]);
      setSelectedSensors([]);
      setSessionTitle("");
    } catch (error) {
      console.error("Error al iniciar sesión:", error);
      toast({
        title: "Error",
        description: error instanceof Error ? error.message : "No se pudo iniciar la sesión",
        variant: "destructive",
      });
    } finally {
      setIsStarting(false);
    }
  };

  // Función para finalizar una sesión
  const finishSession = async (session: any) => {
    try {
      setIsFinishingSession(true);
      await apiRequest("DELETE", `/api/sessions/${session.id}`);

      // Actualizar la lista de sesiones y cámaras
      await Promise.all([
        queryClient.invalidateQueries({ queryKey: ["/api/sessions"] }),
        queryClient.invalidateQueries({ queryKey: ["/api/cameras"] })
      ]);

      // Mostrar diálogo de éxito
      setSuccessSessionInfo({
        title: session.title || `Sesión ${session.id}`,
        id: session.id,
        timestamp: new Date().toISOString()
      });
      setShowSuccessDialog(true);
      
    } catch (error) {
      toast({
        title: "Error",
        description: error instanceof Error ? error.message : "No se pudo finalizar la sesión",
        variant: "destructive",
      });
    } finally {
      setIsFinishingSession(false);
    }
  };

  // Función para descargar una sesión
  const downloadSession = async (session: any) => {
    try {
      const response = await fetch(`/api/sessions/${session.id}/download`);
      if (!response.ok) throw new Error('Error al descargar');

      const blob = await response.blob();
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      
      // Usar el título de la sesión como nombre del archivo
      const safeTitle = session.title.replace(/[^a-z0-9]/gi, '_').toLowerCase();
      a.download = `${safeTitle}.zip`;
      
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);
    } catch (error) {
      toast({
        title: "Error",
        description: "No se pudo descargar la sesión",
        variant: "destructive",
      });
    }
  };

  // Agregar nuevo estado para controlar la vista en cuadrícula
  const [isGridCollapsed, setIsGridCollapsed] = useState(false);
  const [isDeleteDialogOpen, setIsDeleteDialogOpen] = useState(false);
  const [sessionToDelete, setSessionToDelete] = useState<any>(null);
  const [isFinishingSession, setIsFinishingSession] = useState(false);
  const [showSuccessDialog, setShowSuccessDialog] = useState(false);
  const [successSessionInfo, setSuccessSessionInfo] = useState<{
    title: string;
    id: number;
    timestamp: string;
  } | null>(null);

  // Función para manejar la eliminación de una sesión
  const handleDeleteSession = async (session: any) => {
    setSessionToDelete(session);
    setIsDeleteDialogOpen(true);
  };

  const confirmDeleteSession = async () => {
    if (!sessionToDelete) return;

    try {
      await apiRequest("DELETE", `/api/sessions/${sessionToDelete.id}`);

      // Actualizar la lista de sesiones y cámaras
      await Promise.all([
        queryClient.invalidateQueries({ queryKey: ["/api/sessions"] }),
        queryClient.invalidateQueries({ queryKey: ["/api/cameras"] })
      ]);

      toast({
        title: "Sesión eliminada",
        description: "La sesión se ha eliminado correctamente",
      });
    } catch (error) {
      toast({
        title: "Error",
        description: error instanceof Error ? error.message : "No se pudo eliminar la sesión",
        variant: "destructive",
      });
    } finally {
      setIsDeleteDialogOpen(false);
      setSessionToDelete(null);
    }
  };

  return (
    <div className="container mx-auto p-4 max-w-[1600px] space-y-6">
      <h1 className="text-2xl font-bold">Gestión de Sesiones</h1>
      
      <Tabs defaultValue="new-session" className="w-full">
        <TabsList className="grid w-full grid-cols-2 mb-4 p-1 bg-slate-100 rounded-lg shadow-sm">
          <TabsTrigger 
            value="new-session" 
            className="flex items-center text-base font-medium border border-transparent data-[state=active]:border-blue-500 data-[state=active]:bg-white data-[state=active]:shadow-sm"
          >
            <PlusCircle className="h-5 w-5 mr-2 text-green-600" />
            Nueva Sesión
          </TabsTrigger>
          <TabsTrigger 
            value="history" 
            className="flex items-center text-base font-medium border border-transparent data-[state=active]:border-blue-500 data-[state=active]:bg-white data-[state=active]:shadow-sm"
          >
            <History className="h-5 w-5 mr-2 text-blue-600" />
            Historial de Sesiones
          </TabsTrigger>
        </TabsList>
        
        {/* Pestaña: Nueva Sesión */}
        <TabsContent value="new-session" className="space-y-6 border-t-2 pt-6 border-blue-100">
          <div className="bg-card rounded-lg p-6 border">
            <div className="flex justify-between items-center mb-6">
              <h2 className="text-xl font-bold">Nueva Sesión de Monitoreo</h2>
            </div>
            <div className="mt-4 p-4 bg-blue-50 text-blue-800 rounded-md text-sm">
              <div className="flex items-start">
                <AlertCircle className="h-5 w-5 mr-2 mt-0.5 flex-shrink-0" />
                <div>
                  <p className="font-medium">Grabación y captura de datos</p>
                  <p className="mt-1">Los dispositivos seleccionados serán registrados durante toda la sesión, independientemente de si seleccionas solo cámaras, solo sensores o ambos.</p>
                  <ul className="mt-2 space-y-1 list-disc list-inside ml-2">
                    <li>Las cámaras grabarán de forma sincronizada en formato de alta calidad.</li>
                    <li>Los sensores registrarán cambios en topics como <code className="bg-blue-100 p-0.5 rounded">zigbee2mqtt/livinglab/device</code>, <code className="bg-blue-100 p-0.5 rounded">zigbee2mqtt/livinglab/event</code>, etc.</li>
                    <li>Los datos de sensores se almacenan con nombres amigables para facilitar su identificación.</li>
                    <li>Todo el material será descargable en un único archivo ZIP que incluirá vídeos y datos JSON.</li>
                  </ul>
                </div>
              </div>
            </div>

            {/* Formulario de sesión */}
            <Card>
              <CardHeader>
                <CardTitle>Configuración de la Sesión</CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="flex items-center gap-4">
                  <Input
                    placeholder="Nombre de la sesión (opcional)"
                    value={sessionTitle}
                    onChange={(e) => setSessionTitle(e.target.value)}
                    className="max-w-md"
                  />
                  <Button
                    onClick={startSession}
                    disabled={isStarting || (!selectedCameras.length && !selectedSensors.length) || !!activeSession}
                  >
                    {isStarting ? (
                      <Loader2 className="h-4 w-4 animate-spin mr-2" />
                    ) : (
                      <Play className="h-4 w-4 mr-2" />
                    )}
                    Iniciar Sesión
                  </Button>
                </div>

                <div className="relative">
                  <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                  <Input
                    placeholder="Buscar dispositivos..."
                    value={searchQuery}
                    onChange={(e) => setSearchQuery(e.target.value)}
                    className="pl-9"
                  />
                </div>
              </CardContent>
            </Card>

            {/* Lista de dispositivos */}
            <div className="grid gap-6 grid-cols-1 lg:grid-cols-2 mt-6">
              {/* Tabla de cámaras */}
              <Card>
                <CardHeader>
                  <CardTitle>Cámaras Disponibles</CardTitle>
                </CardHeader>
                <CardContent>
                  <Table>
                    <TableHeader>
                      <TableRow>
                        <TableHead className="w-12"></TableHead>
                        <TableHead>Nombre</TableHead>
                        <TableHead>Dirección IP</TableHead>
                        <TableHead>Estado</TableHead>
                      </TableRow>
                    </TableHeader>
                    <TableBody>
                      {filteredCameras.map((camera) => (
                        <TableRow key={camera.id}>
                          <TableCell>
                            <Checkbox
                              checked={selectedCameras.includes(camera.id)}
                              onCheckedChange={() => toggleCamera(camera.id, camera.status)}
                              disabled={!!activeSession}
                            />
                          </TableCell>
                          <TableCell>{camera.name}</TableCell>
                          <TableCell>{camera.ipAddress}</TableCell>
                          <TableCell>
                            {verifyingCameras.includes(camera.id) ? (
                              <div className="flex items-center">
                                <Loader2 className="h-4 w-4 animate-spin text-blue-500 mr-1" />
                                <span className="text-xs text-blue-500">Verificando...</span>
                              </div>
                            ) : camera.status === 'connected' ? (
                              <div className="flex items-center">
                                <Check className="h-4 w-4 text-green-500 mr-1" />
                                <span className="text-xs text-green-600">Conectada</span>
                              </div>
                            ) : (
                              <div className="flex items-center">
                                <X className="h-4 w-4 text-red-500 mr-1" />
                                <span className="text-xs text-red-600">Desconectada</span>
                              </div>
                            )}
                          </TableCell>
                        </TableRow>
                      ))}
                    </TableBody>
                  </Table>
                </CardContent>
              </Card>

              {/* Tabla de sensores */}
              <Card>
                <CardHeader>
                  <CardTitle>Sensores Disponibles</CardTitle>
                  <CardDescription className="flex justify-between items-center">
                    <span>Sensores publicados en zigbee2mqtt detectados automáticamente</span>
                    <div className="flex items-center">
                      <div className={cn(
                        "w-3 h-3 rounded-full mr-2",
                        isConnected ? "bg-green-500" : "bg-red-500"
                      )}></div>
                      <span className="text-sm font-medium">
                        {isConnected ? "Conectado" : "Desconectado"}
                      </span>
                      {!isConnected && (
                        <button 
                          onClick={() => window.location.reload()}
                          className="ml-2 text-xs text-blue-600 hover:text-blue-800 underline"
                        >
                          Reintentar
                        </button>
                      )}
                    </div>
                  </CardDescription>
                </CardHeader>
                <CardContent>
                  {connectionError && (
                    <Alert variant="destructive" className="mb-4">
                      <AlertTitle>Error de conexión MQTT</AlertTitle>
                      <AlertDescription>
                        {connectionError}
                      </AlertDescription>
                    </Alert>
                  )}
                  <Table>
                    <TableHeader>
                      <TableRow>
                        <TableHead className="w-12"></TableHead>
                        <TableHead>Nombre</TableHead>
                        <TableHead>ID</TableHead>
                        <TableHead>Estado</TableHead>
                      </TableRow>
                    </TableHeader>
                    <TableBody>
                      {filteredSensors.length > 0 ? (
                        // Aplicar paginación a los sensores filtrados
                        filteredSensors
                          .slice((currentPage - 1) * sensorsPerPage, currentPage * sensorsPerPage)
                          .map((sensor: any) => (
                            <TableRow key={sensor.ieee_addr}>
                              <TableCell>
                                <Checkbox
                                  id={`sensor-${sensor.ieee_addr}`}
                                  checked={selectedSensors.includes(sensor.ieee_addr)}
                                  onCheckedChange={(checked) => {
                                    if (typeof checked === 'boolean') {
                                      handleSensorChange(sensor.ieee_addr, checked);
                                    }
                                  }}
                                  disabled={!!activeSession}
                                />
                              </TableCell>
                              <TableCell>
                                <div className="flex flex-col">
                                  <span className="font-medium text-primary">{sensor.friendly_name || 'Sin nombre'}</span>
                                  {sensor.roomName && (
                                    <span className="text-xs text-muted-foreground">{sensor.roomName}</span>
                                  )}
                                </div>
                              </TableCell>
                              <TableCell>
                                <span className="text-xs font-mono bg-slate-100 p-1 rounded">{sensor.ieee_addr}</span>
                              </TableCell>
                              <TableCell>
                                {sensor.status === 'online' ? (
                                  <span className="bg-green-100 text-green-800 text-xs font-medium px-2 py-1 rounded-full flex items-center">
                                    <Check className="h-3 w-3 mr-1" />Online
                                  </span>
                                ) : (
                                  <span className="bg-red-100 text-red-800 text-xs font-medium px-2 py-1 rounded-full flex items-center">
                                    <X className="h-3 w-3 mr-1" />Offline
                                  </span>
                                )}
                              </TableCell>
                            </TableRow>
                          ))
                      ) : (
                        <TableRow>
                          <TableCell colSpan={4} className="text-center py-4 text-muted-foreground">
                            {isConnected 
                              ? "No se encontraron sensores. Espere a que se detecten los dispositivos Zigbee." 
                              : "No se encontraron sensores. Verifique su conexión al servidor MQTT."
                            }
                          </TableCell>
                        </TableRow>
                      )}
                    </TableBody>
                  </Table>
                  
                  {/* Controles de paginación para sensores */}
                  {filteredSensors.length > sensorsPerPage && (
                    <div className="flex items-center justify-between border-t border-gray-200 bg-white px-4 py-3 sm:px-6 mt-2">
                      <div className="hidden sm:flex sm:flex-1 sm:items-center sm:justify-between">
                        <div>
                          <p className="text-sm text-gray-700">
                            Mostrando <span className="font-medium">{Math.min((currentPage - 1) * sensorsPerPage + 1, filteredSensors.length)}</span> a <span className="font-medium">{Math.min(currentPage * sensorsPerPage, filteredSensors.length)}</span> de <span className="font-medium">{filteredSensors.length}</span> sensores
                          </p>
                        </div>
                        <div>
                          <nav className="isolate inline-flex -space-x-px rounded-md shadow-sm" aria-label="Pagination">
                            <button
                              onClick={() => setCurrentPage(page => Math.max(page - 1, 1))}
                              disabled={currentPage === 1}
                              className={cn(
                                "relative inline-flex items-center rounded-l-md px-2 py-2 text-gray-400 ring-1 ring-inset ring-gray-300 hover:bg-gray-50 focus:z-20 focus:outline-offset-0",
                                currentPage === 1 ? "opacity-50 cursor-not-allowed" : "cursor-pointer"
                              )}
                            >
                              <span className="sr-only">Anterior</span>
                              <ChevronLeft className="h-4 w-4" />
                            </button>
                            
                            {/* Mostrar números de página */}
                            {Array.from({ length: Math.ceil(filteredSensors.length / sensorsPerPage) }).map((_, index) => (
                              <button
                                key={index}
                                onClick={() => setCurrentPage(index + 1)}
                                className={cn(
                                  "relative inline-flex items-center px-4 py-2 text-sm font-semibold ring-1 ring-inset ring-gray-300 hover:bg-gray-50 focus:z-20 focus:outline-offset-0",
                                  currentPage === index + 1 ? "bg-blue-50 text-blue-600" : "text-gray-900"
                                )}
                              >
                                {index + 1}
                              </button>
                            ))}
                            
                            <button
                              onClick={() => setCurrentPage(page => Math.min(page + 1, Math.ceil(filteredSensors.length / sensorsPerPage)))}
                              disabled={currentPage >= Math.ceil(filteredSensors.length / sensorsPerPage)}
                              className={cn(
                                "relative inline-flex items-center rounded-r-md px-2 py-2 text-gray-400 ring-1 ring-inset ring-gray-300 hover:bg-gray-50 focus:z-20 focus:outline-offset-0",
                                currentPage >= Math.ceil(filteredSensors.length / sensorsPerPage) ? "opacity-50 cursor-not-allowed" : "cursor-pointer"
                              )}
                            >
                              <span className="sr-only">Siguiente</span>
                              <ChevronRight className="h-4 w-4" />
                            </button>
                          </nav>
                        </div>
                      </div>
                    </div>
                  )}                                    
                </CardContent>
              </Card>
            </div>
          </div>

          {/* Sesión Activa (si existe) */}
          {activeSession && (
            <div className="mt-8 border-t pt-6">
              <h2 className="text-xl font-semibold mb-4 flex items-center">
                <FileVideo className="h-5 w-5 mr-2 text-green-600" />
                <span className="flex items-center gap-2">
                  Sesión Activa
                  <span className="bg-green-100 text-green-800 text-xs font-semibold px-2 py-1 rounded-full">
                    EN PROGRESO
                  </span>
                </span>
              </h2>
              <Card className="border-green-500">
                <CardHeader>
                  <div className="flex justify-between items-start">
                    <CardTitle>{activeSession.title}</CardTitle>
                  </div>
                  <CardDescription>
                    Iniciada el {format(new Date(activeSession.startTime), "PPpp", { locale: es })}
                  </CardDescription>
                </CardHeader>
                <CardContent>
                  <div className="space-y-4">
                    <div className="space-y-2">
                      <div>
                        <strong>Cámaras:</strong> {activeSession.devices.cameras.length} seleccionadas
                      </div>
                      <div>
                        <strong>Sensores:</strong> {activeSession.devices.sensors.length} seleccionados
                      </div>
                    </div>
                    <div className="space-y-2">
                      <div className="flex items-center justify-between">
                        <span className="text-sm font-medium flex items-center gap-1 text-green-600">
                          <span className="inline-block w-2 h-2 rounded-full bg-green-500 animate-pulse"></span>
                          Sesión en progreso
                        </span>
                        <span className="text-sm text-muted-foreground">
                          {elapsedTime[activeSession.id] ? formatTime(elapsedTime[activeSession.id]) : '00:00:00'}
                        </span>
                      </div>
                      <Progress value={100} className="animate-pulse bg-green-100" />
                    </div>
                  </div>
                </CardContent>
                <CardFooter className="justify-end space-x-2">
                  <Button
                    variant="outline"
                    onClick={() => setViewSessionData(activeSession)}
                  >
                    Ver Datos
                  </Button>
                  <Button
                    variant="destructive"
                    onClick={() => finishSession(activeSession)}
                  >
                    <StopCircle className="h-4 w-4 mr-2" />
                    Finalizar Sesión
                  </Button>
                </CardFooter>
              </Card>
            </div>
          )}
        </TabsContent>
        
        {/* Pestaña: Historial de Sesiones */}
        <TabsContent value="history" className="border-t-2 pt-6 border-blue-100">
          <div className="flex justify-between items-center mb-6">
            <h2 className="text-xl font-semibold flex items-center">
              <History className="h-5 w-5 mr-2 text-blue-600" />
              <span className="flex items-center gap-2">
                Historial de Sesiones
                <span className="bg-blue-100 text-blue-800 text-xs font-semibold px-2 py-1 rounded-full">
                  COMPLETADAS
                </span>
              </span>
            </h2>
            <div className="flex items-center gap-4">
              <div className="relative max-w-sm">
                <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                <Input
                  placeholder="Buscar sesiones..."
                  value={sessionSearchQuery}
                  onChange={(e) => setSessionSearchQuery(e.target.value)}
                  className="pl-9"
                />
              </div>
              <Button
                variant="outline"
                size="sm"
                onClick={() => setIsGridCollapsed(!isGridCollapsed)}
              >
                {isGridCollapsed ? <ChevronDown className="h-4 w-4" /> : <ChevronUp className="h-4 w-4" />}
                {isGridCollapsed ? "Expandir" : "Contraer"}
              </Button>
            </div>
          </div>
          
          <div className={cn(
            "grid gap-4",
            isGridCollapsed ? "grid-cols-1 md:grid-cols-2 lg:grid-cols-3" : "grid-cols-1"
          )}>
            {completedSessions.map((session: any) => (
              <Card
                key={session.id}
                className={cn(
                  'border-blue-500',
                  isGridCollapsed ? 'h-[300px] overflow-y-auto' : ''
                )}
              >
                <CardHeader>
                  <div className="flex justify-between items-start">
                    <CardTitle>{session.title}</CardTitle>
                    <Button
                      variant="destructive"
                      size="sm"
                      onClick={() => handleDeleteSession(session)}
                    >
                      <Trash2 className="h-4 w-4" />
                    </Button>
                  </div>
                  <CardDescription>
                    Iniciada el {format(new Date(session.startTime), "PPpp", { locale: es })}
                    {session.endTime && (
                      <> - Finalizada el {format(new Date(session.endTime), "PPpp", { locale: es })}</>
                    )}
                  </CardDescription>
                </CardHeader>
                <CardContent>
                  <div className="space-y-4">
                    <div className="space-y-2">
                      <div>
                        <strong>Cámaras:</strong> {session.devices.cameras.length} seleccionadas
                      </div>
                      <div>
                        <strong>Sensores:</strong> {session.devices.sensors.length} seleccionados
                      </div>
                    </div>
                    <div className="space-y-2">
                      <div className="flex items-center justify-between">
                        <span className="text-sm font-medium flex items-center gap-1 text-blue-600">
                          <span className="inline-block w-2 h-2 rounded-full bg-blue-500"></span>
                          Sesión completada
                        </span>
                        <span className="text-sm text-muted-foreground">
                          {elapsedTime[session.id] ? formatTime(elapsedTime[session.id]) : '00:00:00'}
                        </span>
                      </div>
                    </div>
                  </div>
                </CardContent>
                <CardFooter className="justify-end space-x-2">
                  <Button
                    variant="outline"
                    onClick={() => setViewSessionData(session)}
                  >
                    Ver Datos
                  </Button>
                  <Button
                    variant="outline"
                    onClick={() => downloadSession(session)}
                    disabled={!!activeSession}
                  >
                    <Download className="h-4 w-4 mr-2" />
                    Descargar
                  </Button>
                </CardFooter>
              </Card>
            ))}
          </div>
        </TabsContent>
      </Tabs>

      {/* Diálogo de confirmación para eliminar sesión */}
      <Dialog open={isDeleteDialogOpen} onOpenChange={setIsDeleteDialogOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Confirmar eliminación</DialogTitle>
            <DialogDescription>
              ¿Estás seguro de que deseas eliminar esta sesión? Esta acción no se puede deshacer.
            </DialogDescription>
          </DialogHeader>
          <div className="flex justify-end space-x-2">
            <Button variant="outline" onClick={() => setIsDeleteDialogOpen(false)}>
              Cancelar
            </Button>
            <Button variant="destructive" onClick={confirmDeleteSession}>
              Eliminar
            </Button>
          </div>
        </DialogContent>
      </Dialog>

      {/* Diálogo para ver datos de la sesión */}
      <Dialog open={!!viewSessionData} onOpenChange={() => setViewSessionData(null)}>
        <DialogContent className="max-w-5xl max-h-[90vh] overflow-y-auto">
          <DialogHeader>
            <DialogTitle>Datos de la Sesión</DialogTitle>
            <DialogDescription>
              {viewSessionData?.title} - Iniciada el {viewSessionData && format(new Date(viewSessionData.startTime), "PPpp", { locale: es })}
            </DialogDescription>
          </DialogHeader>
          <div className="space-y-6">
            {/* Grabaciones de video */}
            <div>
              <h3 className="text-lg font-semibold mb-4">Grabaciones</h3>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                {viewSessionData?.devices.cameras.map((camera: any) => (
                  <div key={camera.id} className="border rounded-lg p-4">
                    <h4 className="font-medium mb-2">Cámara {camera.prefix || `cam${camera.id}`}</h4>
                    <video
                      controls
                      className="w-full aspect-video rounded-lg bg-black"
                      src={`/api/recordings/${camera.recordingId}/stream`}
                    />
                  </div>
                ))}
              </div>
            </div>

            {/* Datos de sensores con formato mejorado */}
            {viewSessionData?.devices.sensors.length > 0 && (
              <div>
                <div className="flex items-center justify-between">
                  <h3 className="text-lg font-semibold mb-4">Datos de Sensores</h3>
                  <Button 
                    variant="outline" 
                    size="sm"
                    onClick={() => {
                      if (viewSessionData) {
                        const jsonData = {
                          sensors: viewSessionData.devices.sensors,
                          sensorData: viewSessionData.sensorData,
                          sessionInfo: {
                            id: viewSessionData.id,
                            title: viewSessionData.title,
                            startTime: viewSessionData.startTime,
                            endTime: viewSessionData.endTime
                          }
                        };
                        
                        const blob = new Blob([JSON.stringify(jsonData, null, 2)], { 
                          type: 'application/json' 
                        });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `sensor-data-${viewSessionData.id}.json`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                      }
                    }}
                    className="mr-2"
                  >
                    <FileJson className="w-4 h-4 mr-2" />
                    Exportar JSON
                  </Button>
                </div>
                
                <div className="grid gap-4">
                  {viewSessionData.devices.sensors.map((sensorId: string) => {
                    // Intentar encontrar el friendly_name del sensor
                    const sensorData = viewSessionData.sensorData?.[sensorId] || [];
                    const friendlyName = sensorData.length > 0 && sensorData[0].friendly_name 
                      ? sensorData[0].friendly_name 
                      : sensorId.split('/').pop();
                      
                    return (
                      <div key={sensorId} className="border rounded-lg p-4">
                        <div className="flex justify-between items-start mb-3">
                          <div>
                            <h4 className="font-medium text-primary">{friendlyName}</h4>
                            <p className="text-xs text-muted-foreground mt-1">{sensorId}</p>
                          </div>
                          <Badge variant={sensorData.length > 0 ? "success" : "outline"}>
                            {sensorData.length} mensajes
                          </Badge>
                        </div>
                        
                        {sensorData.length > 0 ? (
                          <Tabs defaultValue="timeline" className="w-full">
                            <TabsList className="mb-2">
                              <TabsTrigger value="timeline">Línea temporal</TabsTrigger>
                              <TabsTrigger value="raw">Datos JSON</TabsTrigger>
                            </TabsList>
                            
                            <TabsContent value="timeline" className="mt-0">
                              <div className="space-y-2 max-h-60 overflow-y-auto p-2">
                                {sensorData.map((data: any, index: number) => (
                                  <div key={index} className="bg-slate-50 p-3 rounded border-l-4 border-blue-500 text-sm">
                                    <div className="flex justify-between mb-1">
                                      <span className="font-medium">{data.messageType || 'Actualización'}</span>
                                      <span className="text-xs text-muted-foreground">
                                        {data.timestamp ? new Date(data.timestamp).toLocaleTimeString() : 'Sin fecha'}
                                      </span>
                                    </div>
                                    <div className="grid grid-cols-2 gap-x-4 gap-y-1 mt-2 text-xs">
                                      {data.contact !== null && (
                                        <div className="col-span-1 flex items-center">
                                          <span className="font-medium mr-1">Contacto:</span> 
                                          <span className={data.contact ? 'text-green-600' : 'text-red-600'}>
                                            {data.contact ? 'Cerrado' : 'Abierto'}
                                          </span>
                                        </div>
                                      )}
                                      {data.occupancy !== null && (
                                        <div className="col-span-1 flex items-center">
                                          <span className="font-medium mr-1">Movimiento:</span> 
                                          <span className={data.occupancy ? 'text-green-600' : 'text-slate-600'}>
                                            {data.occupancy ? 'Detectado' : 'No detectado'}
                                          </span>
                                        </div>
                                      )}
                                      {data.battery !== undefined && data.battery > 0 && (
                                        <div className="col-span-1 flex items-center">
                                          <span className="font-medium mr-1">Batería:</span> {data.battery}%
                                        </div>
                                      )}
                                      {data.linkquality !== undefined && (
                                        <div className="col-span-1 flex items-center">
                                          <span className="font-medium mr-1">Calidad:</span> {data.linkquality}
                                        </div>
                                      )}
                                    </div>
                                  </div>
                                ))}
                              </div>
                            </TabsContent>
                            
                            <TabsContent value="raw" className="mt-0">
                              <pre className="bg-muted p-4 rounded-lg overflow-auto max-h-60 text-xs">
                                {JSON.stringify(sensorData, null, 2)}
                              </pre>
                            </TabsContent>
                          </Tabs>
                        ) : (
                          <div className="bg-slate-50 p-4 rounded-lg text-center text-muted-foreground">
                            No hay datos disponibles para este sensor
                          </div>
                        )}
                      </div>
                    );
                  })}
                </div>
              </div>
            )}
          </div>
        </DialogContent>
      </Dialog>
      
      {/* Diálogo de éxito al finalizar una sesión */}
      <Dialog open={showSuccessDialog} onOpenChange={setShowSuccessDialog}>
        <DialogContent className="max-w-md">
          <DialogHeader>
            <DialogTitle className="flex items-center gap-2 text-green-600">
              <Check className="h-6 w-6 text-green-600" />
              Sesión Finalizada Correctamente
            </DialogTitle>
            <DialogDescription>
              La sesión ha sido completada y los datos están disponibles para su revisión.
            </DialogDescription>
          </DialogHeader>
          
          <div className="py-4">
            <Alert className="bg-green-50 border-green-200">
              <AlertCircle className="h-5 w-5 text-green-600" />
              <AlertTitle className="text-green-800">Datos guardados correctamente</AlertTitle>
              <AlertDescription className="text-green-700">
                Los datos de la sesión "{successSessionInfo?.title}" han sido guardados y están disponibles en el historial.
              </AlertDescription>
            </Alert>
            
            <div className="mt-4 p-4 bg-slate-50 rounded-md border">
              <h4 className="text-sm font-medium mb-2 text-slate-700">Información de la sesión:</h4>
              <div className="space-y-2 text-sm">
                <div className="flex items-center gap-2">
                  <FolderClosed className="h-4 w-4 text-blue-600" />
                  <span className="text-slate-600">
                    Ubicación: <span className="font-medium">/sessions/{successSessionInfo?.id}</span>
                  </span>
                </div>
                <div className="flex items-center gap-2">
                  <Save className="h-4 w-4 text-blue-600" />
                  <span className="text-slate-600">
                    Datos disponibles para descargar en formato ZIP
                  </span>
                </div>
              </div>
            </div>
          </div>
          
          <DialogFooter>
            <Button 
              onClick={() => setShowSuccessDialog(false)}
              className="bg-green-600 hover:bg-green-700"
            >
              Entendido
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  );
}