import { useQuery, useQueryClient } from "@tanstack/react-query";
import { Recording, Camera } from "@shared/schema";
import { Card, CardContent, CardHeader, CardTitle, CardDescription, CardFooter } from "@/components/ui/card";
import { Textarea } from "@/components/ui/textarea";
import { Loader2, Play, Download, Search, Check, X, ChevronUp, ChevronDown, ChevronLeft, ChevronRight, Trash2, History, PlusCircle, FileVideo, StopCircle, Save, FolderClosed, AlertCircle, FileJson, Plus, Calendar as CalendarIcon, Filter } from "lucide-react";
import { format, formatDuration, intervalToDuration, isAfter, isBefore, parse, set } from "date-fns";
import { enUS } from "date-fns/locale";
import { Button } from "@/components/ui/button";
import { Label } from "@/components/ui/label";
import { useToast } from "@/hooks/use-toast";
import { apiRequest } from "@/lib/queryClient";
import { useState, useEffect } from "react";
import { useLocation } from "wouter";
import { ErrorState } from "@/components/ui/error-state";
import { LoadingAnimation } from "@/components/ui/loading-animation";
import { Input } from "@/components/ui/input";
import { Checkbox } from "@/components/ui/checkbox";
// import useMqtt from "@/hooks/use-mqtt";
import useSimpleMqtt from "@/hooks/use-simple-mqtt";
import { Alert, AlertTitle, AlertDescription } from "@/components/ui/alert";
import { Badge } from "@/components/ui/badge";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogFooter
} from "@/components/ui/dialog";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Progress } from "@/components/ui/progress";
import cn from 'classnames';
import {
  Tabs,
  TabsContent,
  TabsList,
  TabsTrigger,
} from "@/components/ui/tabs";
import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger,
} from "@/components/ui/collapsible";
import { Calendar } from "@/components/ui/calendar";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";

export default function SessionsPage() {
  // Get URL search parameters to check if a specific session should be viewed
  const [location] = useLocation();
  const searchParams = new URLSearchParams(location.split('?')[1]);
  const sessionIdParam = searchParams.get('sessionId');
  const { data: cameras } = useQuery<Camera[]>({
    queryKey: ["/api/cameras"],
  });

  // const { sensors } = useMqtt();
  const mqttClient = useSimpleMqtt();
  const { sensors, isConnected, connectionError, sensorCount, getAllData } = mqttClient;
  const { toast } = useToast();
  const queryClient = useQueryClient();

  // States for form and search
  const [searchQuery, setSearchQuery] = useState("");
  const [sessionSearchQuery, setSessionSearchQuery] = useState("");
  const [selectedCameras, setSelectedCameras] = useState<number[]>([]);
  const [selectedSensors, setSelectedSensors] = useState<string[]>([]);
  const [sessionTitle, setSessionTitle] = useState("");
  const [labTitle, setLabTitle] = useState("");
  const [sessionDescription, setSessionDescription] = useState("");
  const [participants, setParticipants] = useState("");
  const [researcher, setResearcher] = useState("");
  const [isStarting, setIsStarting] = useState(false);
  const [viewSessionData, setViewSessionData] = useState<any>(null);

  // State for advanced date filtering
  const [showAdvancedFilters, setShowAdvancedFilters] = useState(false);
  const [startDate, setStartDate] = useState<Date | undefined>(undefined);
  const [endDate, setEndDate] = useState<Date | undefined>(undefined);
  const [startTime, setStartTime] = useState<string>("");
  const [endTime, setEndTime] = useState<string>("");
  const [isDateFilterActive, setIsDateFilterActive] = useState(false);

  // State for the time counter
  const [elapsedTime, setElapsedTime] = useState<{ [key: string]: number }>({});
  const [sessionStatus, setSessionStatus] = useState<{ [key: string]: string }>({});
  const [websocket, setWebsocket] = useState<WebSocket | null>(null);

  const { data: sessions, isLoading: isLoadingSessions } = useQuery({
    queryKey: ["/api/sessions"],
    refetchInterval: 5000, // Update every 5 seconds
  });

  // Get the current active session (if it exists)
  const activeSession = sessions && Array.isArray(sessions) ? 
    sessions.find((session: any) => session.status === 'active') : undefined;
  
  // Get the completed sessions
  const completedSessions = sessions && Array.isArray(sessions) ? 
    sessions.filter((session: any) => session.status === 'completed') : [];

  // Filter completed sessions based on search with support for OR operator and metadata
  // Function to combine date and time into a single Date object
  const combineDateTime = (date?: Date, timeStr?: string): Date | undefined => {
    if (!date) return undefined;
    
    if (timeStr) {
      try {
        // Parse time string in format "HH:MM"
        const [hours, minutes] = timeStr.split(':').map(Number);
        return set(new Date(date), { hours, minutes, seconds: 0, milliseconds: 0 });
      } catch (error) {
        console.error("Error parsing time:", error);
      }
    }
    
    // Return date at midnight if no time provided
    return set(new Date(date), { hours: 0, minutes: 0, seconds: 0, milliseconds: 0 });
  };

  // Apply date filter to sessions
  const filteredSessions = completedSessions.filter((session: any) => {
    // Apply date filter if active
    if (isDateFilterActive && startDate) {
      const sessionStartTime = new Date(session.startTime);
      const filterStartDateTime = combineDateTime(startDate, startTime);
      
      if (filterStartDateTime && isAfter(filterStartDateTime, sessionStartTime)) {
        return false;
      }
      
      if (endDate) {
        const filterEndDateTime = combineDateTime(endDate, endTime);
        // If endTime is empty, set the end time to 23:59:59
        const adjustedEndDateTime = endTime 
          ? filterEndDateTime 
          : set(new Date(endDate), { hours: 23, minutes: 59, seconds: 59 });
        
        if (adjustedEndDateTime && isBefore(adjustedEndDateTime, sessionStartTime)) {
          return false;
        }
      }
    }
    
    // Apply text search filter if query exists
    if (!sessionSearchQuery.trim()) return true;
    
    // Split the search query into terms (using space as separator)
    const searchTerms = sessionSearchQuery.toLowerCase().split(' ').filter(term => term.trim() !== '');
    
    // Return true if ANY of the search terms match (OR operator)
    return searchTerms.some(term => {
      // Treat term as a potential tag if it starts with #
      const isTagSearch = term.startsWith('#');
      const tagTerm = isTagSearch ? term.substring(1) : term;
      
      // Search in main fields
      const titleMatch = session.title?.toLowerCase().includes(tagTerm) || false;
      const idMatch = session.id?.toString().includes(tagTerm) || false;
      
      // Search in metadata fields
      const labTitleMatch = session.labTitle?.toLowerCase().includes(tagTerm) || false;
      const researcherMatch = session.researcher?.toLowerCase().includes(tagTerm) || false;
      const descriptionMatch = session.sessionDescription?.toLowerCase().includes(tagTerm) || false;
      
      // Special handling for participants (as tags)
      let participantsMatch = false;
      if (session.participants) {
        const participantsList = session.participants.split(',').map((p: string) => p.trim().toLowerCase());
        // If it's a tag search, check exact matches in participants
        if (isTagSearch) {
          participantsMatch = participantsList.some((p: string) => p === tagTerm);
        } else {
          // Otherwise check for partial matches
          participantsMatch = participantsList.some((p: string) => p.includes(tagTerm));
        }
      }
      
      // Enhanced search for date-related terms
      const dateString = session.startTime ? new Date(session.startTime).toLocaleDateString() : '';
      const timeString = session.startTime ? new Date(session.startTime).toLocaleTimeString() : '';
      const dateMatch = dateString.toLowerCase().includes(tagTerm) || timeString.toLowerCase().includes(tagTerm);
      
      // Check if search term might be referring to device count or types
      const cameraCountMatch = (tagTerm.includes('camera') || tagTerm === 'cam' || tagTerm === 'video') && 
                             session.devices?.cameras?.length > 0;
      const sensorCountMatch = tagTerm.includes('sensor') && session.devices?.sensors?.length > 0;
      
      // Search in device IDs and names
      let deviceMatch = false;
      if (session.devices?.cameras?.length > 0) {
        deviceMatch = session.devices.cameras.some((camera: any) => 
          (camera.name?.toLowerCase()?.includes(tagTerm) || false) ||
          (camera.prefix?.toLowerCase()?.includes(tagTerm) || false)
        );
      }
      
      // Also search in sensor IDs and friendly names
      let sensorIdMatch = false;
      if (session.devices?.sensors?.length > 0) {
        sensorIdMatch = session.devices.sensors.some((sensorId: string) => {
          if (!sensorId) return false;
          return sensorId.toLowerCase().includes(tagTerm);
        });
      }
      
      // Search in sensor data if available
      let sensorDataMatch = false;
      if (session.sensorData) {
        // Try to find matches in sensor data friendly names or values
        sensorDataMatch = Object.values(session.sensorData).some((dataPoints: any) => {
          if (!Array.isArray(dataPoints) || dataPoints.length === 0) return false;
          return dataPoints.some((point: any) => {
            if (!point) return false;
            // Search in friendly name
            if (point.friendly_name && point.friendly_name.toLowerCase().includes(tagTerm)) return true;
            // Search in topic
            if (point.topic && point.topic.toLowerCase().includes(tagTerm)) return true;
            // Search in values as JSON string
            const jsonStr = JSON.stringify(point).toLowerCase();
            return jsonStr.includes(tagTerm);
          });
        });
      }
      
      // Return true if ANY field matches (OR operation)
      return titleMatch || idMatch || labTitleMatch || researcherMatch || 
             descriptionMatch || participantsMatch || dateMatch ||
             cameraCountMatch || sensorCountMatch || deviceMatch ||
             sensorIdMatch || sensorDataMatch;
    });
  });

  // Connect to WebSocket for real-time updates
  useEffect(() => {
    const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
    const hostIp = import.meta.env.VITE_HOST_IP || "192.168.0.20";
    const wsUrl = `${protocol}//${window.location.host}/ws`;
    
    console.log(`Connecting to WebSocket at ${wsUrl}`);
    const ws = new WebSocket(wsUrl);
    
    ws.onopen = () => {
      console.log('Connected to WebSocket server');
      setWebsocket(ws);
    };
    
    ws.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        console.log('Received WebSocket message:', data);
        
        if (data.type === "session_deleted") {
          // Invalidar la caché cuando se elimina una sesión
          queryClient.invalidateQueries({ queryKey: ["/api/sessions"] });
          queryClient.invalidateQueries({ queryKey: ["/api/cameras"] });
          
          toast({
            title: "Session deleted",
            description: "The session has been deleted by the server",
          });
        } else if (data.type === "camera_updated") {
          // Update camera status
          queryClient.invalidateQueries({ queryKey: ["/api/cameras"] });
        } else if (data.type === "session_updated") {
          // Update sessions
          queryClient.invalidateQueries({ queryKey: ["/api/sessions"] });
        }
      } catch (error) {
        console.error('Error processing WebSocket message:', error);
      }
    };
    
    ws.onerror = (error) => {
      console.error('WebSocket error:', error);
    };
    
    ws.onclose = () => {
      console.log('WebSocket connection closed');
      setWebsocket(null);
    };
    
    return () => {
      if (ws.readyState === WebSocket.OPEN) {
        ws.close();
      }
    };
  }, []);

  // Effect to auto-open a session dialog when a sessionId is provided in the URL
  useEffect(() => {
    if (sessionIdParam && sessions && Array.isArray(sessions)) {
      // Find the session with the provided ID
      const session = sessions.find((s: any) => s.id.toString() === sessionIdParam);
      if (session) {
        // Set the session to view and ensure we're on the right tab ('history' for completed, 'new-session' for active)
        setViewSessionData(session);
      }
    }
  }, [sessionIdParam, sessions]);

  // Update time counter for active sessions
  useEffect(() => {
    const interval = setInterval(() => {
      if (sessions && Array.isArray(sessions)) {
        const newElapsedTime = { ...elapsedTime };
        const newStatus = { ...sessionStatus };

        sessions.forEach((session: any) => {
          const start = new Date(session.startTime).getTime();
          if (session.status === 'active') {
            newElapsedTime[session.id] = Math.floor((Date.now() - start) / 1000);
            newStatus[session.id] = 'active';
          } else if (session.status === 'completed') {
            const end = new Date(session.endTime).getTime();
            newElapsedTime[session.id] = Math.floor((end - start) / 1000);
            newStatus[session.id] = 'completed';
          }
        });

        setElapsedTime(newElapsedTime);
        setSessionStatus(newStatus);
      }
    }, 1000);

    return () => clearInterval(interval);
  }, [sessions]);

  // Format duration
  const formatTime = (seconds: number) => {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;
    return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
  };

  // Filtrar dispositivos basados en la búsqueda
  const filteredCameras = cameras?.filter(camera => {
    if (!searchQuery) return true;
    return camera.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
           camera.ipAddress.includes(searchQuery);
  }) || [];

  // Validar que los sensores tienen IEEE address y están bien formateados
  const validSensors = (sensors || []).filter((sensor: any) => 
    sensor && typeof sensor === 'object' && sensor.ieee_addr && typeof sensor.ieee_addr === 'string'
  );
  
  // Filtrar sensores según la búsqueda
  const filteredSensors = validSensors.filter((sensor: any) => {
    if (!searchQuery) return true;
    return (sensor.friendly_name || '').toLowerCase().includes(searchQuery.toLowerCase()) ||
           (sensor.ieee_addr || '').includes(searchQuery);
  });

  // State for tracking cameras being verified
  const [verifyingCameras, setVerifyingCameras] = useState<number[]>([]);
  
  // State for sensor table pagination
  const [currentPage, setCurrentPage] = useState<number>(1);
  const sensorsPerPage = 5;
  
  // State for active tab (cameras or sensors)
  const [activeTab, setActiveTab] = useState<'cameras' | 'sensors'>('cameras');

  // Verificar cámara mediante ping
  const checkCameraStatus = async (cameraId: number) => {
    try {
      // Agregar cámara a la lista de verificación
      setVerifyingCameras(prev => [...prev, cameraId]);
      
      const response = await apiRequest("GET", `/api/cameras/${cameraId}/ping`);
      const result = await response.json();
      
      console.log(`Verificación de cámara ${cameraId}: ${result.status}`);
      
      // Actualizar la cache de TanStack Query para reflejar el nuevo estado
      queryClient.setQueryData(
        ["/api/cameras"],
        (oldData: Camera[] | undefined) => {
          if (!oldData) return undefined;
          
          return oldData.map(camera => 
            camera.id === cameraId 
              ? { ...camera, status: result.status } 
              : camera
          );
        }
      );
      
      // Quitar cámara de la lista de verificación
      setVerifyingCameras(prev => prev.filter(id => id !== cameraId));
      return result.status;
    } catch (error) {
      console.error(`Error verificando cámara ${cameraId}:`, error);
      // Quitar cámara de la lista de verificación en caso de error
      setVerifyingCameras(prev => prev.filter(id => id !== cameraId));
      return 'disconnected';
    }
  };

  // Manejar selección de dispositivos
  const toggleCamera = async (cameraId: number, status: string) => {
    // Verificar si la cámara está desconectada solo cuando se intenta seleccionar
    const isSelected = selectedCameras.includes(cameraId);
    
    // Si no está seleccionada, verificar su estado en tiempo real con ping
    if (!isSelected) {
      // Verificar si ya estamos comprobando esta cámara
      if (verifyingCameras.includes(cameraId)) {
        toast({
          title: "In progress",
          description: "This camera is already being verified, please wait...",
        });
        return;
      }
      
      toast({
        title: "Verifying camera",
        description: "Checking availability using ping...",
        duration: 2000,
      });
      
      // Verificar mediante ping el estado actual de la cámara
      const currentStatus = await checkCameraStatus(cameraId);
      
      // Si la cámara está desconectada y se intenta seleccionar
      if (currentStatus !== 'connected') {
        toast({
          title: "Error",
          description: "This camera cannot be selected because it does not respond to ping",
          variant: "destructive",
          duration: 3000,
        });
        return;
      }
      
      toast({
        title: "Camera available",
        description: "The camera has been verified and is available",
        duration: 2000,
      });
    }
    
    // Cambiar el estado de selección
    setSelectedCameras(prev =>
      isSelected
        ? prev.filter(id => id !== cameraId)
        : [...prev, cameraId]
    );
    
    console.log(`Camera ${cameraId} ${isSelected ? 'unselected' : 'selected'}, status: ${status}`);
  };

  const handleSensorChange = (sensorId: string, checked: boolean) => {
    // Log para depuración
    console.log(`Cambiando sensor ${sensorId} a ${checked ? 'seleccionado' : 'deseleccionado'}`);
    console.log('Estado previo de sensores:', selectedSensors);
    
    // Verificar que sensorId es una cadena válida
    if (!sensorId || typeof sensorId !== 'string' || sensorId.trim() === '') {
      console.error('ID de sensor inválido:', sensorId);
      return;
    }
    
    // Asegurar que el ID del sensor es único y no se confunda con otros
    const normalizedSensorId = sensorId.trim();
    
    // Implementación con copia inmutable para evitar problemas de referencia
    setSelectedSensors(prevSelected => {
      if (checked) {
        // Evitar duplicados
        if (prevSelected.includes(normalizedSensorId)) {
          return prevSelected; // No hacer cambios si ya está seleccionado
        }
        // Añadir el sensor a la selección
        console.log(`-> Sensor ${normalizedSensorId} añadido a la selección`);
        return [...prevSelected, normalizedSensorId];
      } else {
        // Eliminar el sensor si está seleccionado
        if (!prevSelected.includes(normalizedSensorId)) {
          return prevSelected; // No hacer cambios si no estaba seleccionado
        }
        console.log(`-> Sensor ${normalizedSensorId} eliminado de la selección`);
        return prevSelected.filter(id => id !== normalizedSensorId);
      }
    });
  };
  
  // Efecto para registrar cambios en la selección de sensores
  useEffect(() => {
    console.log('Sensores seleccionados actualizados:', selectedSensors);
  }, [selectedSensors]);
  
  // Efecto para resetear la paginación cuando cambie el filtro de búsqueda
  useEffect(() => {
    setCurrentPage(1);
  }, [searchQuery]);

  // Iniciar nueva sesión
  const startSession = async () => {
    if (!selectedCameras.length && !selectedSensors.length) {
      toast({
        title: "Error",
        description: "Select at least one device to start the session",
        variant: "destructive",
      });
      return;
    }

    setIsStarting(true);
    try {
      // Primero, obtener todos los datos MQTT actuales para incluirlos 
      // en el payload de la sesión - esto asegura que se guarden correctamente
      // Obtener datos MQTT pero limitar su tamaño para evitar errores 413 Payload Too Large
      const originalSensorData = getAllData();
      
      // Crear una versión limitada con sólo los metadatos esenciales
      // En lugar de enviar todos los datos históricos, enviaremos solo una referencia
      const sensorData = {
        sensors: originalSensorData.sensors || [],
        sensorData: {}, // Vacío intencionalmente - se almacenará en el servidor por separado
        specificSensorData: {} // Vacío intencionalmente - se almacenará en el servidor por separado
      };
      
      console.log("Configuración de sesión para sensores:", {
        selectedSensors,
        sensorCount: originalSensorData.sensors ? originalSensorData.sensors.length : 0,
        selectedCount: selectedSensors.length
      });
      
      // Verificar cámaras disponibles
      if (cameras && Array.isArray(cameras)) {
        console.log("Cámaras disponibles:", cameras.length);
      } else {
        console.log("No hay cámaras disponibles o no es un array:", cameras);
      }

      // Crear la sesión solo con los metadatos de configuración
      const response = await apiRequest("POST", "/api/sessions", {
        title: sessionTitle || `Sesión ${format(new Date(), 'dd/MM/yyyy HH:mm')}`,
        labTitle: labTitle,
        sessionDescription: sessionDescription,
        participants: participants,
        researcher: researcher,
        devices: {
          cameras: selectedCameras.map(id => {
            // Encontrar la cámara en el array
            const camera = cameras && Array.isArray(cameras) ? cameras.find(c => Number(c.id) === Number(id)) : null;
            return {
              id,
              prefix: camera ? camera.recordingPrefix || `cam${id}` : `cam${id}`
            };
          }),
          sensors: selectedSensors
        },
        // Enviar metadatos reducidos para evitar error 413 Payload Too Large
        sensorMetadata: {
          selectedSensorIds: selectedSensors,
          sensorCount: selectedSensors.length,
          hasSensors: selectedSensors.length > 0,
          includedTopics: selectedSensors.map(id => `zigbee2mqtt/livinglab/${id}`),
          timestamp: new Date().toISOString()
        }
      });

      // Notificar a la interfaz que la sesión ha sido iniciada
      if (websocket && websocket.readyState === WebSocket.OPEN && response) {
        try {
          // Extraer el ID de la respuesta de manera segura
          const sessionData = await response.json();
          console.log("Respuesta de creación de sesión:", sessionData);
          
          if (sessionData && sessionData.id) {
            websocket.send(JSON.stringify({
              type: "session_started",
              sessionId: sessionData.id
            }));
          }
        } catch (err) {
          console.error("Error al procesar respuesta de sesión:", err);
        }
      }

      // Actualizar lista de grabaciones y sesiones
      await Promise.all([
        queryClient.invalidateQueries({ queryKey: ["/api/recordings"] }),
        queryClient.invalidateQueries({ queryKey: ["/api/sessions"] })
      ]);

      toast({
        title: "Session started",
        description: "Recording and data capture has begun",
      });

      // Limpiar formulario
      setSelectedCameras([]);
      setSelectedSensors([]);
      setSessionTitle("");
      setLabTitle("");
      setSessionDescription("");
      setParticipants("");
      setResearcher("");
    } catch (error) {
      console.error("Error al iniciar sesión:", error);
      toast({
        title: "Error",
        description: error instanceof Error ? error.message : "Could not start the session",
        variant: "destructive",
      });
    } finally {
      setIsStarting(false);
    }
  };

  // Function to end a session
  const finishSession = async (session: any) => {
    try {
      setIsFinishingSession(true);
      await apiRequest("DELETE", `/api/sessions/${session.id}`);

      // Update the list of sessions and cameras
      await Promise.all([
        queryClient.invalidateQueries({ queryKey: ["/api/sessions"] }),
        queryClient.invalidateQueries({ queryKey: ["/api/cameras"] })
      ]);

      // Show success dialog
      setSuccessSessionInfo({
        title: session.title || `Sesión ${session.id}`,
        id: session.id,
        timestamp: new Date().toISOString()
      });
      setShowSuccessDialog(true);
      
    } catch (error) {
      toast({
        title: "Error",
        description: error instanceof Error ? error.message : "Could not finish the session",
        variant: "destructive",
      });
    } finally {
      setIsFinishingSession(false);
    }
  };

  // Function to download a session
  const downloadSession = async (session: any) => {
    try {
      const response = await fetch(`/api/sessions/${session.id}/download`);
      if (!response.ok) throw new Error('Error al descargar');

      const blob = await response.blob();
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      
      // Use the session title as the filename
      const safeTitle = session.title.replace(/[^a-z0-9]/gi, '_').toLowerCase();
      a.download = `${safeTitle}.zip`;
      
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);
    } catch (error) {
      toast({
        title: "Error",
        description: "No se pudo descargar la sesión",
        variant: "destructive",
      });
    }
  };

  // Add new state to control the grid view
  const [isGridCollapsed, setIsGridCollapsed] = useState(false);
  const [isDeleteDialogOpen, setIsDeleteDialogOpen] = useState(false);
  const [sessionToDelete, setSessionToDelete] = useState<any>(null);
  const [isFinishingSession, setIsFinishingSession] = useState(false);
  const [showSuccessDialog, setShowSuccessDialog] = useState(false);
  const [successSessionInfo, setSuccessSessionInfo] = useState<{
    title: string;
    id: number;
    timestamp: string;
  } | null>(null);

  // Function to handle session deletion
  const handleDeleteSession = async (session: any) => {
    setSessionToDelete(session);
    setIsDeleteDialogOpen(true);
  };

  const confirmDeleteSession = async () => {
    if (!sessionToDelete) return;

    try {
      // Use permanent=true to tell the server to permanently delete the session
      await apiRequest("DELETE", `/api/sessions/${sessionToDelete.id}?permanent=true`);

      // Update the list of sessions and cameras
      await Promise.all([
        queryClient.invalidateQueries({ queryKey: ["/api/sessions"] }),
        queryClient.invalidateQueries({ queryKey: ["/api/cameras"] })
      ]);

      toast({
        title: "Session deleted",
        description: "The session has been permanently deleted",
      });
    } catch (error) {
      console.error("Error deleting session:", error);
      toast({
        title: "Error",
        description: error instanceof Error ? error.message : "Could not delete the session",
        variant: "destructive",
      });
    } finally {
      setIsDeleteDialogOpen(false);
      setSessionToDelete(null);
    }
  };

  // Session loading states 
  if (isLoadingSessions) {
    return (
      <div className="flex items-center justify-center h-screen">
        <LoadingAnimation 
          type="spinner"
          text="Loading sessions..."
          size="lg"
          color="primary"
        />
      </div>
    );
  }

  // Error state when sessions can't be loaded
  if (sessions === undefined && !isLoadingSessions) {
    return (
      <div className="flex items-center justify-center h-screen">
        <div className="max-w-md w-full">
          <ErrorState 
            type="server"
            title="Error loading sessions"
            description="Unable to load session data from the server. Please try again."
            action={() => window.location.reload()}
            actionLabel="Refresh Page"
          />
        </div>
      </div>
    );
  }

  return (
    <div className="container mx-auto p-4 max-w-[1600px] space-y-6">
      <h1 className="text-2xl font-bold">Session Management</h1>
      
      <Tabs defaultValue="new-session" className="w-full">
        <TabsList className="grid w-full grid-cols-2 mb-4 p-1 bg-slate-100 rounded-lg shadow-sm">
          <TabsTrigger 
            value="new-session" 
            className="flex items-center text-base font-medium border border-transparent data-[state=active]:border-blue-500 data-[state=active]:bg-white data-[state=active]:shadow-sm"
          >
            <PlusCircle className="h-5 w-5 mr-2 text-green-600" />
            New Session
          </TabsTrigger>
          <TabsTrigger 
            value="history" 
            className="flex items-center text-base font-medium border border-transparent data-[state=active]:border-blue-500 data-[state=active]:bg-white data-[state=active]:shadow-sm"
          >
            <History className="h-5 w-5 mr-2 text-blue-600" />
            Session History
          </TabsTrigger>
        </TabsList>
        
        {/* Tab: New Session */}
        <TabsContent value="new-session" className="space-y-6 border-t-2 pt-6 border-blue-100">
          <div className="bg-card rounded-lg p-6 border">
            <div className="flex justify-between items-center mb-6">
              <div className="flex items-center gap-3">
                <h2 className="text-xl font-bold">New Monitoring Session</h2>
                <Collapsible className="inline-block">
                  <CollapsibleTrigger asChild>
                    <Button variant="outline" className="flex items-center gap-1 text-amber-600 bg-amber-50 border-amber-200 hover:bg-amber-100 hover:text-amber-700 py-1 px-3 h-auto text-sm">
                      <AlertCircle className="h-3 w-3" />
                      <span>Info</span>
                    </Button>
                  </CollapsibleTrigger>
                  <CollapsibleContent className="absolute z-10 mt-2 bg-white border border-amber-200 rounded-md shadow-lg p-4 max-w-lg">
                    <div className="bg-amber-50 text-amber-800 rounded-md text-sm border border-amber-200 p-4">
                      <div className="flex items-start">
                        <AlertCircle className="h-5 w-5 mr-2 mt-0.5 flex-shrink-0 text-amber-600" />
                        <div>
                          <p className="font-medium">Recording and Data Capture</p>
                          <p className="mt-1">The selected devices will be recorded throughout the entire session.</p>
                          <ul className="mt-2 space-y-1 list-disc list-inside ml-2">
                            <li>Cameras will record synchronously in high-quality format</li>
                            <li>Sensors will capture data from all configured MQTT topics</li>
                            <li>Sensor data is stored with friendly names to facilitate identification</li>
                            <li>All sensor data is captured in both raw format and structured CSV format</li>
                            <li>All material will be downloadable as a single ZIP file that includes videos and data</li>
                          </ul>
                        </div>
                      </div>
                    </div>
                  </CollapsibleContent>
                </Collapsible>
              </div>
            </div>

            {/* Session Configuration - Main Container */}
            <Card className="border border-gray-200">
              <CardHeader className="border-b">
                <CardTitle>Session Configuration</CardTitle>
              </CardHeader>
              <CardContent className="space-y-6 p-4">
                {/* Session Details */}
                <div className="grid gap-6 grid-cols-1 lg:grid-cols-2 border rounded-md p-4 bg-slate-50">
                  <div>
                    <Label htmlFor="labTitle" className="text-sm font-medium mb-1 block">
                      Lab Title
                    </Label>
                    <Input
                      id="labTitle"
                      placeholder="Enter laboratory title"
                      value={labTitle}
                      onChange={(e) => setLabTitle(e.target.value)}
                    />
                  </div>

                  <div>
                    <Label htmlFor="researcher" className="text-sm font-medium mb-1 block">
                      Researcher Name
                    </Label>
                    <Input
                      id="researcher"
                      placeholder="Enter researcher name"
                      value={researcher}
                      onChange={(e) => setResearcher(e.target.value)}
                    />
                  </div>

                  <div className="lg:col-span-2">
                    <Label htmlFor="participants" className="text-sm font-medium mb-1 block">
                      Participants (separate with commas)
                    </Label>
                    <Input
                      id="participants"
                      placeholder="e.g. John Smith, Jane Doe"
                      value={participants}
                      onChange={(e) => setParticipants(e.target.value)}
                    />
                  </div>

                  <div className="lg:col-span-2">
                    <Label htmlFor="sessionDescription" className="text-sm font-medium mb-1 flex justify-between">
                      <span>Session Description</span>
                      <span className="text-xs text-gray-500">
                        {sessionDescription.length}/300 characters
                      </span>
                    </Label>
                    <Textarea
                      id="sessionDescription"
                      placeholder="Enter session description (max 300 characters)"
                      value={sessionDescription}
                      onChange={(e) => {
                        // Limit to 300 characters
                        if (e.target.value.length <= 300) {
                          setSessionDescription(e.target.value);
                        }
                      }}
                      className="h-20 resize-none"
                    />
                  </div>
                </div>

                {/* Search with tags */}
                <div className="space-y-4">
                  <div className="relative">
                    <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                    <Input
                      placeholder="Search devices..."
                      value={searchQuery}
                      onChange={(e) => setSearchQuery(e.target.value)}
                      className="pl-9 border border-gray-300"
                    />
                  </div>
                  
                  {/* Tags for search criteria (OR) - only display when there are active tags */}
                  <div className="flex gap-2 flex-wrap">
                    {searchQuery.split(' ').filter(tag => tag.trim() !== '').length > 0 && 
                      searchQuery.split(' ').filter(tag => tag.trim() !== '').map((tag, index) => (
                        <Badge 
                          key={index} 
                          variant="outline" 
                          className="bg-gray-100 hover:bg-gray-200 px-3 py-1 border-gray-300 text-gray-700 cursor-pointer"
                          onClick={() => {
                            // Remove this tag from search query
                            const newQuery = searchQuery.split(' ')
                              .filter(t => t !== tag)
                              .join(' ');
                            setSearchQuery(newQuery);
                          }}
                        >
                          {tag}
                          <X className="h-3 w-3 ml-1 text-gray-400" />
                        </Badge>
                    ))}
                  </div>
                  
                  <div className="border-t border-gray-200 pt-2"></div>
                </div>

                {/* Device selection with active states */}
                <div>
                  {/* Device Tabs */}
                  <div className="grid gap-6 grid-cols-1 lg:grid-cols-2">
                    {/* Cameras section */}
                    <div className={cn(
                      "border rounded-md overflow-hidden transition-all duration-200",
                      activeTab === 'cameras' ? "border-gray-400 shadow-sm" : "border-gray-200 opacity-80"
                    )}>
                      <div 
                        className="p-3 border-b bg-gray-50 flex justify-between items-center cursor-pointer"
                        onClick={() => setActiveTab('cameras')}
                      >
                        <h3 className="font-medium">Available Cameras</h3>
                      </div>
                      <div className="p-3">
                        <Table>
                          <TableHeader>
                            <TableRow>
                              <TableHead className="w-12"></TableHead>
                              <TableHead>Name</TableHead>
                              <TableHead>IP Address</TableHead>
                              <TableHead>Status</TableHead>
                            </TableRow>
                          </TableHeader>
                          <TableBody>
                            {filteredCameras.map((camera) => (
                              <TableRow key={camera.id}>
                                <TableCell>
                                  <Checkbox
                                    checked={selectedCameras.includes(camera.id)}
                                    onCheckedChange={() => toggleCamera(camera.id, camera.status)}
                                    disabled={!!activeSession}
                                  />
                                </TableCell>
                                <TableCell>{camera.name}</TableCell>
                                <TableCell>{camera.ipAddress}</TableCell>
                                <TableCell>
                                  {verifyingCameras.includes(camera.id) ? (
                                    <div className="flex items-center">
                                      <LoadingAnimation 
                                        type="dots" 
                                        size="sm" 
                                        color="primary" 
                                        showText={false}
                                      />
                                      <span className="text-xs text-blue-500 ml-1">Verifying...</span>
                                    </div>
                                  ) : camera.status === 'connected' ? (
                                    <div className="flex items-center">
                                      <Check className="h-4 w-4 text-green-500 mr-1" />
                                      <span className="text-xs text-green-600">Connected</span>
                                    </div>
                                  ) : (
                                    <div className="flex items-center">
                                      <X className="h-4 w-4 text-red-500 mr-1" />
                                      <span className="text-xs text-red-600">Disconnected</span>
                                    </div>
                                  )}
                                </TableCell>
                              </TableRow>
                            ))}
                          </TableBody>
                        </Table>
                      </div>
                    </div>

                    {/* Sensors section */}
                    <div className={cn(
                      "border rounded-md overflow-hidden transition-all duration-200",
                      activeTab === 'sensors' ? "border-gray-400 shadow-sm" : "border-gray-200 opacity-80"
                    )}>
                      <div 
                        className="p-3 border-b bg-gray-50 flex justify-between items-center cursor-pointer"
                        onClick={() => setActiveTab('sensors')}
                      >
                        <h3 className="font-medium">Available Sensors</h3>
                        <div className="flex items-center">
                          <Badge 
                            variant={isConnected ? "success" : "destructive"} 
                            className="text-xs py-0 px-1.5 h-5"
                          >
                            <div className={cn(
                              "w-1.5 h-1.5 rounded-full mr-1",
                              isConnected ? "bg-green-500" : "bg-red-500"
                            )}></div>
                            <span className="text-[10px] font-medium">
                              {isConnected ? "Connected to MQTT" : "Disconnected"}
                            </span>
                          </Badge>
                        </div>
                      </div>

                      <div className="p-3">
                        {connectionError && (
                          <Alert variant="destructive" className="mb-4 text-xs">
                            <AlertTitle>MQTT Connection Error</AlertTitle>
                            <AlertDescription>
                              {connectionError}
                            </AlertDescription>
                          </Alert>
                        )}
                        
                        <Table>
                          <TableHeader>
                            <TableRow>
                              <TableHead className="w-12"></TableHead>
                              <TableHead>Name</TableHead>
                              <TableHead>ID</TableHead>
                              <TableHead>Status</TableHead>
                            </TableRow>
                          </TableHeader>
                          <TableBody>
                            {filteredSensors.length > 0 ? (
                              // Apply pagination to filtered sensors
                              filteredSensors
                                .slice((currentPage - 1) * sensorsPerPage, currentPage * sensorsPerPage)
                                .map((sensor: any) => (
                                  <TableRow key={sensor.ieee_addr}>
                                    <TableCell>
                                      <Checkbox
                                        id={`sensor-${sensor.ieee_addr}`}
                                        checked={selectedSensors.includes(sensor.ieee_addr)}
                                        onCheckedChange={(checked) => {
                                          if (typeof checked === 'boolean') {
                                            handleSensorChange(sensor.ieee_addr, checked);
                                          }
                                        }}
                                        disabled={!!activeSession}
                                      />
                                    </TableCell>
                                    <TableCell>
                                      <div className="flex flex-col">
                                        <span className="font-medium text-primary">{sensor.friendly_name || 'No name'}</span>
                                        {sensor.roomName && (
                                          <span className="text-xs text-muted-foreground">{sensor.roomName}</span>
                                        )}
                                      </div>
                                    </TableCell>
                                    <TableCell>
                                      <span className="text-xs font-mono bg-slate-100 p-1 rounded">{sensor.ieee_addr}</span>
                                    </TableCell>
                                    <TableCell>
                                      {sensor.status === 'online' ? (
                                        <span className="bg-green-100 text-green-800 text-xs font-medium px-2 py-1 rounded-full flex items-center">
                                          <Check className="h-3 w-3 mr-1" />Online
                                        </span>
                                      ) : (
                                        <span className="bg-red-100 text-red-800 text-xs font-medium px-2 py-1 rounded-full flex items-center">
                                          <X className="h-3 w-3 mr-1" />Offline
                                        </span>
                                      )}
                                    </TableCell>
                                  </TableRow>
                                ))
                            ) : (
                              <TableRow>
                                <TableCell colSpan={4} className="text-center py-4 text-muted-foreground">
                                  {isConnected 
                                    ? "No sensors found. Please check your MQTT configuration." 
                                    : "No sensors found. Check your connection to the MQTT server."
                                  }
                                </TableCell>
                              </TableRow>
                            )}
                          </TableBody>
                        </Table>
                        
                        {/* Pagination controls for sensors */}
                        {filteredSensors.length > sensorsPerPage && (
                          <div className="flex items-center justify-between border-t border-gray-200 bg-white px-4 py-3 sm:px-6 mt-2">
                            <div className="hidden sm:flex sm:flex-1 sm:items-center sm:justify-between">
                              <div>
                                <p className="text-sm text-gray-700">
                                  Showing <span className="font-medium">{Math.min((currentPage - 1) * sensorsPerPage + 1, filteredSensors.length)}</span> to <span className="font-medium">{Math.min(currentPage * sensorsPerPage, filteredSensors.length)}</span> of <span className="font-medium">{filteredSensors.length}</span> sensors
                                </p>
                              </div>
                              <div>
                                <nav className="isolate inline-flex -space-x-px rounded-md shadow-sm" aria-label="Pagination">
                                  <button
                                    onClick={() => setCurrentPage(page => Math.max(page - 1, 1))}
                                    disabled={currentPage === 1}
                                    className={cn(
                                      "relative inline-flex items-center rounded-l-md px-2 py-2 text-gray-400 ring-1 ring-inset ring-gray-300 hover:bg-gray-50 focus:z-20 focus:outline-offset-0",
                                      currentPage === 1 ? "opacity-50 cursor-not-allowed" : "cursor-pointer"
                                    )}
                                  >
                                    <span className="sr-only">Previous</span>
                                    <ChevronLeft className="h-4 w-4" />
                                  </button>
                                  
                                  {/* Display page numbers */}
                                  {Array.from({ length: Math.ceil(filteredSensors.length / sensorsPerPage) }).map((_, index) => (
                                    <button
                                      key={index}
                                      onClick={() => setCurrentPage(index + 1)}
                                      className={cn(
                                        "relative inline-flex items-center px-4 py-2 text-sm font-semibold ring-1 ring-inset ring-gray-300 hover:bg-gray-50 focus:z-20 focus:outline-offset-0",
                                        currentPage === index + 1 ? "bg-blue-50 text-blue-600" : "text-gray-900"
                                      )}
                                    >
                                      {index + 1}
                                    </button>
                                  ))}
                                  
                                  <button
                                    onClick={() => setCurrentPage(page => Math.min(page + 1, Math.ceil(filteredSensors.length / sensorsPerPage)))}
                                    disabled={currentPage >= Math.ceil(filteredSensors.length / sensorsPerPage)}
                                    className={cn(
                                      "relative inline-flex items-center rounded-r-md px-2 py-2 text-gray-400 ring-1 ring-inset ring-gray-300 hover:bg-gray-50 focus:z-20 focus:outline-offset-0",
                                      currentPage >= Math.ceil(filteredSensors.length / sensorsPerPage) ? "opacity-50 cursor-not-allowed" : "cursor-pointer"
                                    )}
                                  >
                                    <span className="sr-only">Next</span>
                                    <ChevronRight className="h-4 w-4" />
                                  </button>
                                </nav>
                              </div>
                            </div>
                          </div>
                        )}
                      </div>
                    </div>
                  </div>
                </div>

                {/* Session Name and Start Button - Moved to bottom */}
                <div className="border-t border-gray-200 pt-6 mt-6">
                  <div className="grid gap-4 grid-cols-1 lg:grid-cols-2">
                    <div>
                      <Label htmlFor="sessionTitle" className="text-sm font-medium mb-1 block">
                        Session Name
                      </Label>
                      <Input
                        id="sessionTitle"
                        placeholder="Enter session name (optional)"
                        value={sessionTitle}
                        onChange={(e) => setSessionTitle(e.target.value)}
                      />
                    </div>
                    <div className="flex items-center justify-end lg:justify-end mt-4 lg:mt-0">
                      <Button
                        onClick={startSession}
                        disabled={isStarting || (!selectedCameras.length && !selectedSensors.length) || !!activeSession}
                        className="bg-blue-500 hover:bg-blue-600 w-full lg:w-auto px-8"
                      >
                        {isStarting ? (
                          <div className="flex items-center">
                            <LoadingAnimation 
                              type="dots" 
                              size="sm" 
                              color="primary" 
                              showText={false}
                            />
                            <span className="ml-2">Starting...</span>
                          </div>
                        ) : (
                          <Play className="h-4 w-4 mr-2" />
                        )}
                        Start Session
                      </Button>
                    </div>
                  </div>
                </div>
              </CardContent>
            </Card>
          </div>

          {/* Active Session (if exists) */}
          {activeSession && (
            <div className="mt-8 border-t pt-6">
              <h2 className="text-xl font-semibold mb-4 flex items-center">
                <FileVideo className="h-5 w-5 mr-2 text-green-600" />
                <span className="flex items-center gap-2">
                  Active Session
                  <span className="bg-green-100 text-green-800 text-xs font-semibold px-2 py-1 rounded-full">
                    IN PROGRESS
                  </span>
                </span>
              </h2>
              <Card className="border-green-500">
                <CardHeader>
                  <div className="flex justify-between items-start">
                    <CardTitle>{activeSession.title}</CardTitle>
                  </div>
                  <CardDescription>
                    Started on {format(new Date(activeSession.startTime), "PPpp", { locale: enUS })}
                  </CardDescription>
                </CardHeader>
                <CardContent>
                  <div className="space-y-4">
                    {/* Show lab title and researcher if available */}
                    {(activeSession.labTitle || activeSession.researcher) && (
                      <div className="bg-green-50 p-2 rounded-md mb-2">
                        {activeSession.labTitle && (
                          <div className="text-sm mb-1">
                            <span className="font-medium">Lab:</span> {activeSession.labTitle}
                          </div>
                        )}
                        {activeSession.researcher && (
                          <div className="text-sm">
                            <span className="font-medium">Researcher:</span> {activeSession.researcher}
                          </div>
                        )}
                      </div>
                    )}
                    
                    {/* Session description if available */}
                    {activeSession.sessionDescription && (
                      <div className="bg-gray-50 p-2 rounded-md text-sm mb-3">
                        <span className="font-medium block mb-1">Description:</span>
                        <p className="text-gray-700 italic line-clamp-2">{activeSession.sessionDescription}</p>
                      </div>
                    )}
                    
                    <div className="space-y-2">
                      <div>
                        <strong>Cameras:</strong> {activeSession.devices.cameras.length} selected
                      </div>
                      <div>
                        <strong>Sensors:</strong> {activeSession.devices.sensors.length} selected
                      </div>
                      {activeSession.participants && (
                        <div>
                          <strong>Participants:</strong> 
                          <div className="flex flex-wrap gap-1 mt-1">
                            {activeSession.participants.split(',').map((participant, index) => (
                              participant.trim() && (
                                <Badge key={index} variant="outline" className="bg-gray-100 text-xs">
                                  {participant.trim()}
                                </Badge>
                              )
                            ))}
                          </div>
                        </div>
                      )}
                    </div>
                    <div className="space-y-2">
                      <div className="flex items-center justify-between">
                        <span className="text-sm font-medium flex items-center gap-1 text-green-600">
                          <span className="inline-block w-2 h-2 rounded-full bg-green-500 animate-pulse"></span>
                          Session in progress
                        </span>
                        <span className="text-sm text-muted-foreground">
                          {elapsedTime[activeSession.id] ? formatTime(elapsedTime[activeSession.id]) : '00:00:00'}
                        </span>
                      </div>
                      <Progress value={100} className="animate-pulse bg-green-100" />
                    </div>
                  </div>
                </CardContent>
                <CardFooter className="justify-end space-x-2">
                  <Button
                    variant="outline"
                    onClick={() => setViewSessionData(activeSession)}
                  >
                    View Data
                  </Button>
                  <Button
                    variant="destructive"
                    onClick={() => finishSession(activeSession)}
                  >
                    <StopCircle className="h-4 w-4 mr-2" />
                    End Session
                  </Button>
                </CardFooter>
              </Card>
            </div>
          )}
        </TabsContent>
        
        {/* Session History Tab */}
        <TabsContent value="history" className="border-t-2 pt-6 border-blue-100">
          <div className="flex justify-between items-center mb-6">
            <h2 className="text-xl font-semibold flex items-center">
              <History className="h-5 w-5 mr-2 text-blue-600" />
              <span className="flex items-center gap-2">
                Session History
                <span className="bg-blue-100 text-blue-800 text-xs font-semibold px-2 py-1 rounded-full">
                  COMPLETED
                </span>
              </span>
            </h2>
            <div className="flex flex-col gap-2">
              <div className="flex items-center gap-4">
                <div className="relative flex-grow">
                  <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                  <Input
                    placeholder="Search sessions (use spaces for OR searches, #tag for tags)..."
                    value={sessionSearchQuery}
                    onChange={(e) => setSessionSearchQuery(e.target.value)}
                    className="pl-9"
                  />
                </div>
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => setShowAdvancedFilters(!showAdvancedFilters)}
                  className={cn(showAdvancedFilters && "bg-blue-50 text-blue-700 border-blue-200")}
                >
                  <Filter className="h-4 w-4 mr-1" />
                  Filter
                </Button>
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => setIsGridCollapsed(!isGridCollapsed)}
                >
                  {isGridCollapsed ? <ChevronDown className="h-4 w-4" /> : <ChevronUp className="h-4 w-4" />}
                  {isGridCollapsed ? "Expand" : "Collapse"}
                </Button>
              </div>
              
              {/* Advanced date filter UI */}
              {showAdvancedFilters && (
                <div className="bg-gray-50 border border-gray-200 rounded-md p-4 mt-2">
                  <h3 className="text-sm font-medium mb-3">Date Range Filter</h3>
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                      <Label htmlFor="start-date" className="block mb-1 text-sm">Start Date</Label>
                      <div className="flex gap-2">
                        <Popover>
                          <PopoverTrigger asChild>
                            <Button
                              variant="outline"
                              className={cn(
                                "w-full justify-start text-left font-normal",
                                !startDate && "text-muted-foreground"
                              )}
                            >
                              <CalendarIcon className="mr-2 h-4 w-4" />
                              {startDate ? format(startDate, "PPP", { locale: enUS }) : <span>Select date</span>}
                            </Button>
                          </PopoverTrigger>
                          <PopoverContent className="w-auto p-0">
                            <Calendar
                              mode="single"
                              selected={startDate}
                              onSelect={setStartDate}
                              initialFocus
                            />
                          </PopoverContent>
                        </Popover>
                        <Input
                          id="start-time"
                          type="time"
                          value={startTime}
                          onChange={(e) => setStartTime(e.target.value)}
                          className="w-[120px]"
                        />
                      </div>
                    </div>
                    
                    <div>
                      <Label htmlFor="end-date" className="block mb-1 text-sm">End Date</Label>
                      <div className="flex gap-2">
                        <Popover>
                          <PopoverTrigger asChild>
                            <Button
                              variant="outline"
                              className={cn(
                                "w-full justify-start text-left font-normal",
                                !endDate && "text-muted-foreground"
                              )}
                            >
                              <CalendarIcon className="mr-2 h-4 w-4" />
                              {endDate ? format(endDate, "PPP", { locale: enUS }) : <span>Select date</span>}
                            </Button>
                          </PopoverTrigger>
                          <PopoverContent className="w-auto p-0">
                            <Calendar
                              mode="single"
                              selected={endDate}
                              onSelect={setEndDate}
                              initialFocus
                            />
                          </PopoverContent>
                        </Popover>
                        <Input
                          id="end-time"
                          type="time"
                          value={endTime}
                          onChange={(e) => setEndTime(e.target.value)}
                          className="w-[120px]"
                        />
                      </div>
                    </div>
                  </div>
                  
                  <div className="flex justify-end mt-4 gap-2">
                    <Button 
                      variant="outline" 
                      size="sm"
                      onClick={() => {
                        setStartDate(undefined);
                        setEndDate(undefined);
                        setStartTime("");
                        setEndTime("");
                        setIsDateFilterActive(false);
                      }}
                    >
                      Clear
                    </Button>
                    <Button 
                      variant="default" 
                      size="sm"
                      onClick={() => {
                        if (startDate) {
                          setIsDateFilterActive(true);
                        } else {
                          toast({
                            title: "Missing date",
                            description: "Please select at least a start date to filter",
                            variant: "destructive",
                          });
                        }
                      }}
                      disabled={!startDate}
                    >
                      Apply Filter
                    </Button>
                  </div>
                  
                  {isDateFilterActive && (
                    <div className="mt-2 text-xs bg-blue-50 text-blue-700 p-2 rounded-md flex items-center">
                      <span className="font-medium">Active date filter:</span>
                      <span className="ml-1">
                        {startDate && format(startDate, "PPP", { locale: enUS })}
                        {startTime && ` at ${startTime}`}
                        {endDate && ` - ${format(endDate, "PPP", { locale: enUS })}`}
                        {endTime && ` at ${endTime}`}
                      </span>
                      <Button
                        variant="ghost"
                        size="sm"
                        className="p-0 h-auto ml-2 text-blue-700 hover:text-blue-900 hover:bg-blue-100"
                        onClick={() => setIsDateFilterActive(false)}
                      >
                        <X className="h-3 w-3" />
                      </Button>
                    </div>
                  )}
                </div>
              )}
              
              {/* Tags for search criteria (OR) */}
              <div className="flex gap-2 flex-wrap">
                {sessionSearchQuery.split(' ').filter(tag => tag.trim() !== '').length > 0 && 
                  sessionSearchQuery.split(' ').filter(tag => tag.trim() !== '').map((tag, index) => (
                    <Badge 
                      key={index} 
                      variant={tag.startsWith('#') ? "default" : "outline"} 
                      className={cn(
                        "px-3 py-1 cursor-pointer",
                        tag.startsWith('#') 
                          ? "bg-primary text-primary-foreground hover:bg-primary/80" 
                          : "bg-gray-100 hover:bg-gray-200 text-gray-700 border-gray-300"
                      )}
                      onClick={() => {
                        // Remove this tag from search query
                        const newQuery = sessionSearchQuery.split(' ')
                          .filter(t => t !== tag)
                          .join(' ');
                        setSessionSearchQuery(newQuery);
                      }}
                    >
                      {tag}
                      <X className="h-3 w-3 ml-1" />
                    </Badge>
                ))}
              </div>
              
              {sessionSearchQuery && (
                <div className="text-xs text-muted-foreground">
                  <span className="font-medium">Search in:</span> title, metadata, participants, devices, dates, and sensor data
                </div>
              )}
            </div>
          </div>
          
          {/* Contador de resultados de búsqueda */}
          {sessionSearchQuery.trim() && (
            <div className="mb-4 text-sm">
              <span className="font-medium">{filteredSessions.length}</span> {filteredSessions.length === 1 ? 'result' : 'results'} found for search term{sessionSearchQuery.split(' ').filter(t => t.trim()).length > 1 ? 's' : ''}.
            </div>
          )}
          
          {/* Mensaje cuando no hay resultados */}
          {sessionSearchQuery.trim() && filteredSessions.length === 0 ? (
            <div className="bg-gray-50 border border-gray-200 rounded-lg p-8 text-center">
              <div className="inline-flex items-center justify-center w-12 h-12 rounded-full bg-gray-100 mb-4">
                <Search className="h-6 w-6 text-gray-400" />
              </div>
              <h3 className="text-lg font-medium mb-2">No sessions found</h3>
              <p className="text-gray-500 mb-4">
                No sessions match your search criteria. Try different keywords or clear your search.
              </p>
              <Button 
                variant="outline" 
                onClick={() => setSessionSearchQuery("")}
                className="mx-auto"
              >
                <X className="h-4 w-4 mr-2" />
                Clear search
              </Button>
            </div>
          ) : (
            <div className={cn(
              "grid gap-4",
              isGridCollapsed ? "grid-cols-1 md:grid-cols-2 lg:grid-cols-3" : "grid-cols-1"
            )}>
              {filteredSessions.map((session: any) => (
              <Card
                key={session.id}
                className={cn(
                  'border-blue-500',
                  isGridCollapsed ? 'h-[300px] overflow-y-auto' : ''
                )}
              >
                <CardHeader>
                  <div className="flex justify-between items-start">
                    <CardTitle>{session.title}</CardTitle>
                    <Button
                      variant="destructive"
                      size="sm"
                      onClick={() => handleDeleteSession(session)}
                    >
                      <Trash2 className="h-4 w-4" />
                    </Button>
                  </div>
                  <CardDescription>
                    Started on {format(new Date(session.startTime), "PPpp", { locale: enUS })}
                    {session.endTime && (
                      <> - Ended on {format(new Date(session.endTime), "PPpp", { locale: enUS })}</>
                    )}
                  </CardDescription>
                </CardHeader>
                <CardContent>
                  <div className="space-y-4">
                    {/* Show lab title and researcher if available */}
                    {(session.labTitle || session.researcher) && (
                      <div className="bg-blue-50 p-2 rounded-md mb-2">
                        {session.labTitle && (
                          <div className="text-sm mb-1">
                            <span className="font-medium">Lab:</span> {session.labTitle}
                          </div>
                        )}
                        {session.researcher && (
                          <div className="text-sm">
                            <span className="font-medium">Researcher:</span> {session.researcher}
                          </div>
                        )}
                      </div>
                    )}
                    
                    {/* Session description if available */}
                    {session.sessionDescription && (
                      <div className="bg-gray-50 p-2 rounded-md text-sm mb-3">
                        <span className="font-medium block mb-1">Description:</span>
                        <p className="text-gray-700 italic line-clamp-2">{session.sessionDescription}</p>
                      </div>
                    )}
                    
                    <div className="space-y-2">
                      <div>
                        <strong>Cameras:</strong> {session.devices.cameras.length} selected
                      </div>
                      <div>
                        <strong>Sensors:</strong> {session.devices.sensors.length} selected
                      </div>
                      {session.participants && (
                        <div>
                          <strong>Participants:</strong> 
                          <div className="flex flex-wrap gap-1 mt-1">
                            {session.participants.split(',').map((participant, index) => (
                              participant.trim() && (
                                <Badge key={index} variant="outline" className="bg-gray-100 text-xs">
                                  {participant.trim()}
                                </Badge>
                              )
                            ))}
                          </div>
                        </div>
                      )}
                    </div>
                    <div className="space-y-2">
                      <div className="flex items-center justify-between">
                        <span className="text-sm font-medium flex items-center gap-1 text-blue-600">
                          <span className="inline-block w-2 h-2 rounded-full bg-blue-500"></span>
                          Session completed
                        </span>
                        <span className="text-sm text-muted-foreground">
                          {elapsedTime[session.id] ? formatTime(elapsedTime[session.id]) : '00:00:00'}
                        </span>
                      </div>
                    </div>
                  </div>
                </CardContent>
                <CardFooter className="justify-end space-x-2">
                  <Button
                    variant="outline"
                    onClick={() => setViewSessionData(session)}
                  >
                    View Data
                  </Button>
                  <Button
                    variant="outline"
                    onClick={() => downloadSession(session)}
                    disabled={!!activeSession}
                  >
                    <Download className="h-4 w-4 mr-2" />
                    Download
                  </Button>
                </CardFooter>
              </Card>
            ))}
          </div>
          )}
        </TabsContent>
      </Tabs>

      {/* Delete confirmation dialog */}
      <Dialog open={isDeleteDialogOpen} onOpenChange={setIsDeleteDialogOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Confirm Deletion</DialogTitle>
            <DialogDescription>
              Are you sure you want to delete this session? This action cannot be undone.
            </DialogDescription>
          </DialogHeader>
          <div className="flex justify-end space-x-2">
            <Button variant="outline" onClick={() => setIsDeleteDialogOpen(false)}>
              Cancel
            </Button>
            <Button variant="destructive" onClick={confirmDeleteSession}>
              Delete
            </Button>
          </div>
        </DialogContent>
      </Dialog>

      {/* Session data dialog */}
      <Dialog open={!!viewSessionData} onOpenChange={() => setViewSessionData(null)}>
        <DialogContent className="max-w-5xl max-h-[90vh] overflow-y-auto">
          <DialogHeader>
            <DialogTitle>Session Data</DialogTitle>
            <DialogDescription>
              {viewSessionData?.title} - Started on {viewSessionData && format(new Date(viewSessionData.startTime), "PPpp", { locale: enUS })}
            </DialogDescription>
          </DialogHeader>
          <div className="space-y-6">
            {/* Session metadata */}
            {(viewSessionData?.labTitle || viewSessionData?.researcher || viewSessionData?.participants || viewSessionData?.sessionDescription) && (
              <div className="bg-gray-50 p-4 rounded-md border">
                <h3 className="text-lg font-semibold mb-3">Session Details</h3>
                <div className="grid gap-3 text-sm">
                  {viewSessionData?.labTitle && (
                    <div>
                      <span className="font-medium">Lab Title:</span> {viewSessionData.labTitle}
                    </div>
                  )}
                  {viewSessionData?.researcher && (
                    <div>
                      <span className="font-medium">Researcher:</span> {viewSessionData.researcher}
                    </div>
                  )}
                  {viewSessionData?.participants && (
                    <div>
                      <span className="font-medium">Participants:</span>
                      <div className="flex flex-wrap gap-1 mt-1">
                        {viewSessionData.participants.split(',').map((participant, index) => (
                          participant.trim() && (
                            <Badge key={index} variant="outline" className="bg-blue-50 text-xs">
                              {participant.trim()}
                            </Badge>
                          )
                        ))}
                      </div>
                    </div>
                  )}
                  {viewSessionData?.sessionDescription && (
                    <div>
                      <span className="font-medium">Description:</span>
                      <p className="mt-1 text-gray-700">{viewSessionData.sessionDescription}</p>
                    </div>
                  )}
                </div>
              </div>
            )}
            {/* Video recordings */}
            <div>
              <h3 className="text-lg font-semibold mb-4">Recordings</h3>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                {viewSessionData?.devices.cameras.map((camera: any) => (
                  <div key={camera.id} className="border rounded-lg p-4">
                    <h4 className="font-medium mb-2">Camera {camera.prefix || `cam${camera.id}`}</h4>
                    <video
                      controls
                      className="w-full aspect-video rounded-lg bg-black"
                      src={`/api/recordings/${camera.recordingId}/stream`}
                    />
                  </div>
                ))}
              </div>
            </div>

            {/* Sensor data with improved format */}
            {viewSessionData?.devices.sensors.length > 0 && (
              <div>
                <div className="flex items-center justify-between">
                  <h3 className="text-lg font-semibold mb-4">Sensor Data</h3>
                  <Button 
                    variant="outline" 
                    size="sm"
                    onClick={() => {
                      if (viewSessionData) {
                        const jsonData = {
                          sensors: viewSessionData.devices.sensors,
                          sensorData: viewSessionData.sensorData,
                          sessionInfo: {
                            id: viewSessionData.id,
                            title: viewSessionData.title,
                            startTime: viewSessionData.startTime,
                            endTime: viewSessionData.endTime
                          }
                        };
                        
                        const blob = new Blob([JSON.stringify(jsonData, null, 2)], { 
                          type: 'application/json' 
                        });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `sensor-data-${viewSessionData.id}.json`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                      }
                    }}
                    className="mr-2"
                  >
                    <FileJson className="w-4 h-4 mr-2" />
                    Export JSON
                  </Button>
                </div>
                
                <div className="grid gap-4">
                  {viewSessionData.devices.sensors.map((sensorId: string) => {
                    // Try to find the sensor's friendly_name
                    const sensorData = viewSessionData.sensorData?.[sensorId] || [];
                    const friendlyName = sensorData.length > 0 && sensorData[0].friendly_name 
                      ? sensorData[0].friendly_name 
                      : sensorId.split('/').pop();
                      
                    return (
                      <div key={sensorId} className="border rounded-lg p-4">
                        <div className="flex justify-between items-start mb-3">
                          <div>
                            <h4 className="font-medium text-primary">{friendlyName}</h4>
                            <p className="text-xs text-muted-foreground mt-1">{sensorId}</p>
                          </div>
                          <Badge variant={sensorData.length > 0 ? "success" : "outline"}>
                            {sensorData.length} messages
                          </Badge>
                        </div>
                        
                        {sensorData.length > 0 ? (
                          <Tabs defaultValue="timeline" className="w-full">
                            <TabsList className="mb-2">
                              <TabsTrigger value="timeline">Timeline</TabsTrigger>
                              <TabsTrigger value="raw">JSON Data</TabsTrigger>
                            </TabsList>
                            
                            <TabsContent value="timeline" className="mt-0">
                              <div className="space-y-2 max-h-60 overflow-y-auto p-2">
                                {sensorData.map((data: any, index: number) => (
                                  <div key={index} className="bg-slate-50 p-3 rounded border-l-4 border-blue-500 text-sm">
                                    <div className="flex justify-between mb-1">
                                      <span className="font-medium">{data.messageType || 'Update'}</span>
                                      <span className="text-xs text-muted-foreground">
                                        {data.timestamp ? new Date(data.timestamp).toLocaleTimeString() : 'No date'}
                                      </span>
                                    </div>
                                    <div className="grid grid-cols-2 gap-x-4 gap-y-1 mt-2 text-xs">
                                      {data.contact !== null && (
                                        <div className="col-span-1 flex items-center">
                                          <span className="font-medium mr-1">Contact:</span> 
                                          <span className={data.contact ? 'text-green-600' : 'text-red-600'}>
                                            {data.contact ? 'Closed' : 'Open'}
                                          </span>
                                        </div>
                                      )}
                                      {data.occupancy !== null && (
                                        <div className="col-span-1 flex items-center">
                                          <span className="font-medium mr-1">Motion:</span> 
                                          <span className={data.occupancy ? 'text-green-600' : 'text-slate-600'}>
                                            {data.occupancy ? 'Detected' : 'Not detected'}
                                          </span>
                                        </div>
                                      )}
                                      {data.battery !== undefined && data.battery > 0 && (
                                        <div className="col-span-1 flex items-center">
                                          <span className="font-medium mr-1">Battery:</span> {data.battery}%
                                        </div>
                                      )}
                                      {data.linkquality !== undefined && (
                                        <div className="col-span-1 flex items-center">
                                          <span className="font-medium mr-1">Signal:</span> {data.linkquality}
                                        </div>
                                      )}
                                    </div>
                                  </div>
                                ))}
                              </div>
                            </TabsContent>
                            
                            <TabsContent value="raw" className="mt-0">
                              <pre className="bg-muted p-4 rounded-lg overflow-auto max-h-60 text-xs">
                                {JSON.stringify(sensorData, null, 2)}
                              </pre>
                            </TabsContent>
                          </Tabs>
                        ) : (
                          <div className="bg-slate-50 p-4 rounded-lg text-center text-muted-foreground">
                            No data available for this sensor
                          </div>
                        )}
                      </div>
                    );
                  })}
                </div>
              </div>
            )}
          </div>
        </DialogContent>
      </Dialog>
      
      {/* Success dialog when finishing a session */}
      <Dialog open={showSuccessDialog} onOpenChange={setShowSuccessDialog}>
        <DialogContent className="max-w-md">
          <DialogHeader>
            <DialogTitle className="flex items-center gap-2 text-green-600">
              <Check className="h-6 w-6 text-green-600" />
              Session Successfully Completed
            </DialogTitle>
            <DialogDescription>
              The session has been completed and the data is available for review.
            </DialogDescription>
          </DialogHeader>
          
          <div className="py-4">
            <Alert className="bg-green-50 border-green-200">
              <AlertCircle className="h-5 w-5 text-green-600" />
              <AlertTitle className="text-green-800">Data saved successfully</AlertTitle>
              <AlertDescription className="text-green-700">
                The data for session "{successSessionInfo?.title}" has been saved and is available in the history.
              </AlertDescription>
            </Alert>
            
            <div className="mt-4 p-4 bg-slate-50 rounded-md border">
              <h4 className="text-sm font-medium mb-2 text-slate-700">Session information:</h4>
              <div className="space-y-2 text-sm">
                <div className="flex items-center gap-2">
                  <FolderClosed className="h-4 w-4 text-blue-600" />
                  <span className="text-slate-600">
                    Location: <span className="font-medium">/sessions/{successSessionInfo?.id}</span>
                  </span>
                </div>
                <div className="flex items-center gap-2">
                  <Save className="h-4 w-4 text-blue-600" />
                  <span className="text-slate-600">
                    Data available for download in ZIP format
                  </span>
                </div>
              </div>
            </div>
          </div>
          
          <DialogFooter>
            <Button 
              onClick={() => setShowSuccessDialog(false)}
              className="bg-green-600 hover:bg-green-700"
            >
              Understood
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  );
}